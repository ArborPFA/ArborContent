  /// \file PhotonReconstructionAlgorithm.cc
/*
 *
 * PhotonReconstructionAlgorithm.cc source template automatically generated by a class generator
 * Creation date : lun. juin 6 2016
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Eté Rémi
 * @copyright CNRS , IPNL
 */


#include "ArborParticleId/PhotonReconstructionAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"
#include "Pandora/PandoraInternal.h"

#include "ArborObjects/CaloHit.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ClusterHelper.h"

namespace arbor_content
{

ShowerBin::ShowerBin() :
		m_energy(0.f),
		m_isAvailable(true),
		m_isUpToDate(true)
{
	/* nop */
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ShowerBin::Add(const pandora::CaloHit *const pCaloHit)
{
	m_caloHitList.insert(pCaloHit);
	m_isUpToDate = false;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ShowerBin::Add(const pandora::CaloHitList &caloHitList)
{
	m_caloHitList.insert(caloHitList.begin(), caloHitList.end());
	m_isUpToDate = false;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ShowerBin::Assign(const pandora::CaloHitList &caloHitList)
{
	m_caloHitList.clear();
	m_caloHitList.insert(caloHitList.begin(), caloHitList.end());
	m_isUpToDate = false;
}

//------------------------------------------------------------------------------------------------------------------------------------------

const pandora::CaloHitList &ShowerBin::GetCaloHitList() const
{
	return m_caloHitList;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::CaloHitList ShowerBin::GetAvailableCaloHitList(const pandora::Algorithm &algorithm) const
{
	pandora::CaloHitList availableCaloHitList;

	for(pandora::CaloHitList::const_iterator iter = m_caloHitList.begin(), endIter = m_caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		if(!PandoraContentApi::IsAvailable(algorithm, pCaloHit))
			continue;

		availableCaloHitList.insert(pCaloHit);
	}

	return availableCaloHitList;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float ShowerBin::GetAvailableEnergy(const pandora::Algorithm &algorithm) const
{
	float availableEnergy(0.f);

	for(pandora::CaloHitList::const_iterator iter = m_caloHitList.begin(), endIter = m_caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		if(!PandoraContentApi::IsAvailable(algorithm, pCaloHit))
			continue;

		const float energy(pCaloHit->GetHitType() == pandora::ECAL ? pCaloHit->GetElectromagneticEnergy() : pCaloHit->GetHadronicEnergy());
		availableEnergy += energy;
	}

	return availableEnergy;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float ShowerBin::GetEnergy() const
{
	const_cast<ShowerBin*>(this)->CalculateProperties();
	return m_energy;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool ShowerBin::IsAvailable() const
{
	return m_isAvailable;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ShowerBin::SetAvailability(bool availability)
{
	m_isAvailable = availability;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ShowerBin::CalculateProperties()
{
	if(m_isUpToDate)
		return;

	m_energy = 0.f;

	for(pandora::CaloHitList::const_iterator iter = m_caloHitList.begin(), endIter = m_caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		const float energy(pCaloHit->GetHitType() == pandora::ECAL ? pCaloHit->GetElectromagneticEnergy() : pCaloHit->GetHadronicEnergy());
		m_energy += energy;
	}

	m_isUpToDate = true;
}

//------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------

Shower2DHistogram::Shower2DHistogram(const unsigned int nBinsX, const float xLow, const float xHigh, const unsigned int nBinsY, const float yLow,
    const float yHigh):
	m_nBinsX(nBinsX),
	m_xLow(xLow),
	m_xHigh(xHigh),
	m_nBinsY(nBinsY),
	m_yLow(yLow),
	m_yHigh(yHigh)
{
    if ((0 >= nBinsX) || (xHigh - xLow < std::numeric_limits<float>::epsilon()))
        throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    m_xBinWidth = (xHigh - xLow) / static_cast<float>(nBinsX);

    if ((0 >= nBinsY) || (yHigh - yLow < std::numeric_limits<float>::epsilon()))
        throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    m_yBinWidth = (yHigh - yLow) / static_cast<float>(nBinsY);
}

//------------------------------------------------------------------------------------------------------------------------------------------

Shower2DHistogram::Shower2DHistogram(const Shower2DHistogram &rhs) :
	m_xyHistogramMap(rhs.m_xyHistogramMap),
	m_nBinsX(rhs.m_nBinsX),
	m_xLow(rhs.m_xLow),
	m_xHigh(rhs.m_xHigh),
	m_xBinWidth(rhs.m_xBinWidth),
	m_nBinsY(rhs.m_nBinsY),
	m_yLow(rhs.m_yLow),
	m_yHigh(rhs.m_yHigh),
	m_yBinWidth(rhs.m_yBinWidth)
{
	/* nop */
}

//------------------------------------------------------------------------------------------------------------------------------------------

int Shower2DHistogram::GetNBinsX() const
{
	return m_nBinsX;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetXLow() const
{
	return m_xLow;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetXHigh() const
{
	return m_xHigh;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetXBinWidth() const
{
	return m_xBinWidth;
}

//------------------------------------------------------------------------------------------------------------------------------------------

int Shower2DHistogram::GetBinX(float xValue)
{
	if(xValue < m_xLow || xValue > m_xHigh)
		return -1;

	return(std::max(-1, std::min(m_nBinsX, static_cast<int>((xValue - m_xLow) / m_xBinWidth)) ));
}

//------------------------------------------------------------------------------------------------------------------------------------------

int Shower2DHistogram::GetNBinsY() const
{
	return m_nBinsY;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetYLow() const
{
	return m_yLow;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetYHigh() const
{
	return m_yHigh;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetYBinWidth() const
{
	return m_yBinWidth;
}

//------------------------------------------------------------------------------------------------------------------------------------------

int Shower2DHistogram::GetBinY(float yValue)
{
	if(yValue < m_yLow || yValue > m_yHigh)
		return -1;

    return (std::max(-1, std::min(m_nBinsY, static_cast<int>((yValue - m_yLow) / m_yBinWidth)) ));
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::CaloHitList Shower2DHistogram::GetBinCaloHitList(const int binX, const int binY) const
{
	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return pandora::CaloHitList();

    ShowerBinMap::const_iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return pandora::CaloHitList();

    return iterXY->second.GetCaloHitList();
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::CaloHitList Shower2DHistogram::GetBinAvailableCaloHitList(const pandora::Algorithm &algorithm, const int binX, const int binY) const
{
	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return pandora::CaloHitList();

    ShowerBinMap::const_iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return pandora::CaloHitList();

    pandora::CaloHitList caloHitList(iterXY->second.GetCaloHitList());
    pandora::CaloHitList availableCaloHitList;

	for(pandora::CaloHitList::const_iterator iter = caloHitList.begin(), endIter = caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		if(PandoraContentApi::IsAvailable(algorithm, *iter))
			availableCaloHitList.insert(*iter);
	}

    return availableCaloHitList;
}

//------------------------------------------------------------------------------------------------------------------------------------------

unsigned int Shower2DHistogram::GetBinNCaloHits(const int binX, const int binY) const
{
	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return 0;

    ShowerBinMap::const_iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return 0;

    return iterXY->second.GetCaloHitList().size();
}

//------------------------------------------------------------------------------------------------------------------------------------------

unsigned int Shower2DHistogram::GetBinNAvailableCaloHits(const pandora::Algorithm &algorithm, const int binX, const int binY) const
{
	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return 0;

    ShowerBinMap::const_iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return 0;

    pandora::CaloHitList caloHitList(iterXY->second.GetCaloHitList());
    unsigned int nAvailableCaloHits(0);

	for(pandora::CaloHitList::const_iterator iter = caloHitList.begin(), endIter = caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		if(PandoraContentApi::IsAvailable(algorithm, *iter))
			nAvailableCaloHits++;
	}

    return nAvailableCaloHits;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetBinEnergy(const int binX, const int binY) const
{
	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return 0;

    ShowerBinMap::const_iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return 0;

    return iterXY->second.GetEnergy();
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetBinAvailableEnergy(const pandora::Algorithm &algorithm, const int binX, const int binY) const
{
	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return 0;

    ShowerBinMap::const_iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return 0;

    return iterXY->second.GetAvailableEnergy(algorithm);
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::GetMaximumNCaloHits(unsigned int &maximumValue, int &maximumBinX, int &maximumBinY) const
{
    maximumValue = 0;
    maximumBinX = -1; maximumBinY = -1;

    for (int xBin = 0, xBinEnd = m_nBinsX - 1 ; xBin <= xBinEnd; ++xBin)
    {
    	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(xBin);

        if (m_xyHistogramMap.end() == iterX)
            continue;

        for (int yBin = 0, yBinEnd = m_nBinsY - 1 ; yBin <= yBinEnd; ++yBin)
        {
        	ShowerBinMap::const_iterator iterY = iterX->second.find(yBin);

            if (iterX->second.end() == iterY)
                continue;

            const unsigned int nCaloHits(iterY->second.GetCaloHitList().size());

            if (nCaloHits > maximumValue)
            {
                maximumValue = nCaloHits;
                maximumBinX = iterX->first;
                maximumBinY = iterY->first;
            }
        }
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::GetMaximumNAvailableCaloHits(const pandora::Algorithm &algorithm, unsigned int &maximumValue, int &maximumBinX, int &maximumBinY) const
{
    maximumValue = 0;
    maximumBinX = -1; maximumBinY = -1;

    for(TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.begin(), endIterX = m_xyHistogramMap.end() ;
    		endIterX != iterX ; ++iterX)
    {
        for(ShowerBinMap::const_iterator iterY = iterX->second.begin(), endIterY = iterX->second.end() ;
        		endIterY != iterY ; ++iterY)
        {
            pandora::CaloHitList caloHitList(iterY->second.GetCaloHitList());
            unsigned int nAvailableCaloHits(0);

        	for(pandora::CaloHitList::const_iterator iter = caloHitList.begin(), endIter = caloHitList.end() ;
        			endIter != iter ; ++iter)
        	{
        		if(PandoraContentApi::IsAvailable(algorithm, *iter))
        			nAvailableCaloHits++;
        	}

            if (nAvailableCaloHits > maximumValue)
            {
                maximumValue = nAvailableCaloHits;
                maximumBinX = iterX->first;
                maximumBinY = iterY->first;
            }
        }
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::GetMaximumEnergy(float &maximumValue, int &maximumBinX, int &maximumBinY) const
{
    maximumValue = 0.f;
    maximumBinX = -1; maximumBinY = -1;

    for (int xBin = 0, xBinEnd = m_nBinsX - 1 ; xBin <= xBinEnd; ++xBin)
    {
    	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(xBin);

        if (m_xyHistogramMap.end() == iterX)
            continue;

        for (int yBin = 0, yBinEnd = m_nBinsY - 1 ; yBin <= yBinEnd; ++yBin)
        {
        	ShowerBinMap::const_iterator iterY = iterX->second.find(yBin);

            if (iterX->second.end() == iterY)
                continue;

            const float energy(iterY->second.GetEnergy());

            if (energy > maximumValue)
            {
                maximumValue = energy;
                maximumBinX = iterX->first;
                maximumBinY = iterY->first;
            }
        }
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::GetMaximumAvailableEnergy(const pandora::Algorithm &algorithm, float &maximumValue, int &maximumBinX, int &maximumBinY, bool checkBinAvailability) const
{
    maximumValue = 0.f;
    maximumBinX = -1; maximumBinY = -1;

    for (int xBin = 0, xBinEnd = m_nBinsX - 1 ; xBin <= xBinEnd; ++xBin)
    {
    	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(xBin);

        if (m_xyHistogramMap.end() == iterX)
            continue;

        for (int yBin = 0, yBinEnd = m_nBinsY - 1 ; yBin <= yBinEnd; ++yBin)
        {
        	ShowerBinMap::const_iterator iterY = iterX->second.find(yBin);

            if (iterX->second.end() == iterY)
                continue;

            if(checkBinAvailability && !iterY->second.IsAvailable())
            	continue;

            const float energy(iterY->second.GetAvailableEnergy(algorithm));

            if (energy > maximumValue)
            {
                maximumValue = energy;
                maximumBinX = iterX->first;
                maximumBinY = iterY->first;
            }
        }
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::SetBinContent(const int binX, const int binY, const pandora::CaloHitList &caloHitList)
{
    if ((binX < -1) || (binX > m_nBinsX) || (binY < -1) || (binY > m_nBinsY))
        throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    m_xyHistogramMap[binX][binY].Assign(caloHitList);
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::Fill(const float valueX, const float valueY, const pandora::CaloHitList &caloHitList)
{
    const int binX(std::max(-1, std::min(m_nBinsX, static_cast<int>((valueX - m_xLow) / m_xBinWidth)) ));
    const int binY(std::max(-1, std::min(m_nBinsY, static_cast<int>((valueY - m_yLow) / m_yBinWidth)) ));

    ShowerBinMap &yHistogramMap(m_xyHistogramMap[binX]);
    ShowerBinMap::iterator iter = yHistogramMap.find(binY);

    if (yHistogramMap.end() != iter)
    {
        iter->second.Add(caloHitList);
    }
    else
    {
    	std::pair<ShowerBinMap::iterator, bool> inserted(yHistogramMap.insert(ShowerBinMap::value_type(binY, ShowerBin())));

        if (!inserted.second)
            throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);

        inserted.first->second.Add(caloHitList);
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::Fill(const float valueX, const float valueY, const pandora::CaloHit *const pCaloHit)
{
    const int binX(std::max(-1, std::min(m_nBinsX, static_cast<int>((valueX - m_xLow) / m_xBinWidth)) ));
    const int binY(std::max(-1, std::min(m_nBinsY, static_cast<int>((valueY - m_yLow) / m_yBinWidth)) ));

    ShowerBinMap &yHistogramMap(m_xyHistogramMap[binX]);
    ShowerBinMap::iterator iter = yHistogramMap.find(binY);

    if (yHistogramMap.end() != iter)
    {
        iter->second.Add(pCaloHit);
    }
    else
    {
    	std::pair<ShowerBinMap::iterator, bool> inserted(yHistogramMap.insert(ShowerBinMap::value_type(binY, ShowerBin())));

        if (!inserted.second)
            throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);

        inserted.first->second.Add(pCaloHit);
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool Shower2DHistogram::GetBinAvailability(const int binX, const int binY) const
{
	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return true;

    ShowerBinMap::const_iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return true;

    return iterXY->second.IsAvailable();
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::SetBinAvailability(const int binX, const int binY, bool availability)
{
	TwoDShowerBinMap::iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return;

    ShowerBinMap::iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return;

    return iterXY->second.SetAvailability(availability);
}

//------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------

ShowerPeak::ShowerPeak(const pandora::CaloHitList &caloHitList, const ShowerPeak::Bin2DList &binList, const ShowerPeak::Bin2D &maxBin) :
		m_caloHitList(caloHitList),
		m_binList(binList),
		m_maxBin(maxBin)
{
	if(caloHitList.empty())
		throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

	for(pandora::CaloHitList::const_iterator iter = caloHitList.begin(), endIter = caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		const float energy(pCaloHit->GetHitType() == pandora::ECAL ? pCaloHit->GetElectromagneticEnergy() : pCaloHit->GetHadronicEnergy());
		m_energy += energy;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------

ShowerPeak::ShowerPeak(const pandora::CaloHitList &caloHitList, const Bin2D &maxBin) :
		m_caloHitList(caloHitList),
		m_maxBin(maxBin)
{
	if(caloHitList.empty())
		throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

	for(pandora::CaloHitList::const_iterator iter = caloHitList.begin(), endIter = caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		const float energy(pCaloHit->GetHitType() == pandora::ECAL ? pCaloHit->GetElectromagneticEnergy() : pCaloHit->GetHadronicEnergy());
		m_energy += energy;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------

const pandora::CaloHitList &ShowerPeak::GetCaloHitList() const
{
	return m_caloHitList;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float ShowerPeak::GetEnergy() const
{
	return m_energy;
}

//------------------------------------------------------------------------------------------------------------------------------------------

const ShowerPeak::Bin2DList &ShowerPeak::GetBinList() const
{
	return m_binList;
}

//------------------------------------------------------------------------------------------------------------------------------------------

const ShowerPeak::Bin2D &ShowerPeak::GetMaxBin() const
{
	return m_maxBin;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ShowerPeak::AddBin(const Bin2D &bin)
{
	for(Bin2DList::const_iterator iter = m_binList.begin(), endIter = m_binList.end() ;
			endIter != iter ; ++iter)
	{
		if(iter->first == bin.first && iter->second == bin.second)
			return pandora::STATUS_CODE_ALREADY_PRESENT;
	}

	m_binList.push_back(bin);

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ShowerPeak::AddCaloHits(const pandora::CaloHitList &caloHitList)
{
	m_caloHitList.insert(caloHitList.begin(), caloHitList.end());
	m_energy = 0.f;

	for(pandora::CaloHitList::const_iterator iter = caloHitList.begin(), endIter = caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		const float energy(pCaloHit->GetHitType() == pandora::ECAL ? pCaloHit->GetElectromagneticEnergy() : pCaloHit->GetHadronicEnergy());
		m_energy += energy;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::Run()
{
	const pandora::CaloHitList *pCaloHitList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pCaloHitList));

	if(pCaloHitList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	// Extract ecal calo hits
	pandora::CaloHitList allEcalCaloHitList;
	pandora::CaloHitList photonEcalCaloHitList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetECalCaloHitList(pCaloHitList, allEcalCaloHitList, photonEcalCaloHitList));

	Shower2DHistogram thetaPhiProjection(m_projectionNThetaBins, -1.f*M_PI, M_PI, m_projectionNPhiBins, -1.f*M_PI, M_PI);
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FillProjectionHistogram(photonEcalCaloHitList, thetaPhiProjection));

	pandora::ClusterVector photonCandidateClusterVector;
	ShowerPeakList showerPeakList;

	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: FindShowerPeakCandidates " << photonCandidateClusterVector.size() << " input clusters" << std::endl );
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindShowerPeakCandidates(thetaPhiProjection, photonCandidateClusterVector, showerPeakList));

	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: MergeNearbyCaloHits " << photonCandidateClusterVector.size() << " input clusters" << std::endl );
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->MergeNearbyCaloHits(photonCandidateClusterVector, allEcalCaloHitList));

	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: RemoveTrackSeededClusters " << photonCandidateClusterVector.size() << " input clusters" << std::endl );
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveTrackSeededClusters(photonCandidateClusterVector));

	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: RemoveNearbyTrackCaloHits " << photonCandidateClusterVector.size() << " input clusters" << std::endl );
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveNearbyTrackCaloHits(photonCandidateClusterVector))

	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: RemoveClustersByProperties " << photonCandidateClusterVector.size() << " input clusters" << std::endl );
	pandora::CaloHitList removalCaloHitList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveClustersByProperties(photonCandidateClusterVector, removalCaloHitList));

	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: MergeNearbyCaloHits " << photonCandidateClusterVector.size() << " input clusters" << std::endl );
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->MergeNearbyCaloHits(photonCandidateClusterVector, removalCaloHitList));

	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: FlagClustersAsPhotons " << photonCandidateClusterVector.size() << " input clusters" << std::endl );
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FlagClustersAsPhotons(photonCandidateClusterVector));

//	[PhotonReconstructionAlgorithm]: FindShowerPeakCandidates 0 input clusters
//	[ VERBOSE "MyMarlinArbor"] maximumInitialEnergy = 3.91544
//	[ VERBOSE "MyMarlinArbor"] showerPeakList.size() = 735
//	[ VERBOSE "MyMarlinArbor"] [PhotonReconstructionAlgorithm]: MergeNearbyCaloHits 82 input clusters
//	[ VERBOSE "MyMarlinArbor"] [PhotonReconstructionAlgorithm]: RemoveTrackSeededClusters 82 input clusters
//	[ VERBOSE "MyMarlinArbor"] [PhotonReconstructionAlgorithm]: RemoveNearbyTrackCaloHits 44 input clusters
//	[ VERBOSE "MyMarlinArbor"] [PhotonReconstructionAlgorithm]: RemoveClustersByProperties 44 input clusters

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::GetECalCaloHitList(const pandora::CaloHitList *const pCaloHitList, pandora::CaloHitList &allEcalCaloHitList, pandora::CaloHitList &photonEcalCaloHitList)
{
	if(pCaloHitList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ;
			endIter != iter ; ++iter)
	{
		if(!PandoraContentApi::IsAvailable(*this, *iter))
			continue;

		if((*iter)->GetHitType() != pandora::ECAL)
			continue;

		allEcalCaloHitList.insert(*iter);

		if((*iter)->GetPseudoLayer() > m_maxCaloHitPseudoLayer)
			continue;

		if(!m_shouldUseIsolatedHits && (*iter)->IsIsolated())
			continue;

		photonEcalCaloHitList.insert(*iter);
	}

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::FindShowerPeakCandidates(const Shower2DHistogram &histogram, pandora::ClusterVector &clusterVector, ShowerPeakList &showerPeakList)
{
	Shower2DHistogram projectionHistogram(histogram);

	float maximumInitialEnergy(0.f);

	// find the highest energy peak in the event
	// and use it as reference
	if(!this->FindInitialShowerPeak(projectionHistogram, showerPeakList, maximumInitialEnergy))
		return pandora::STATUS_CODE_SUCCESS;

	const float energyStep(maximumInitialEnergy/m_showerPeakNSteps);
	float currentEnergyStep(maximumInitialEnergy - energyStep);

	std::cout << "maximumInitialEnergy = " << maximumInitialEnergy << std::endl;

	unsigned int currentStep(m_showerPeakNSteps);

	while(1)
	{
		std::cout << "currentEnergyStep : " << currentEnergyStep << std::endl;

		// check energy step
		if(0 == currentStep)
			break;

		// enlarge shower peaks
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->EnlargePeaks(projectionHistogram, showerPeakList, currentEnergyStep));

		// find new shower peak
		ShowerPeakList newShowerPeakList;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindNewShowerPeaks(projectionHistogram, newShowerPeakList, currentEnergyStep));

		if(!newShowerPeakList.empty())
			showerPeakList.insert(showerPeakList.end(), newShowerPeakList.begin(), newShowerPeakList.end());

		// decrease energy step
		currentEnergyStep -= energyStep;
		--currentStep;
	}

//	currentEnergyStep : 3.13235
//	[ VERBOSE "MyMarlinArbor"] currentEnergyStep : 2.34926
//	[ VERBOSE "MyMarlinArbor"] currentEnergyStep : 1.56617
//	[ VERBOSE "MyMarlinArbor"] currentEnergyStep : 0.783087
//	[ VERBOSE "MyMarlinArbor"] currentEnergyStep : 1.19209e-07
//	[ VERBOSE "MyMarlinArbor"] currentEnergyStep : -0.783087

	std::cout << "showerPeakList.size() = " << showerPeakList.size() << std::endl;

	for(ShowerPeakList::const_iterator iter = showerPeakList.begin(), endIter = showerPeakList.end() ;
			endIter != iter ; ++iter)
	{
		const unsigned int nCaloHits((*iter).GetCaloHitList().size());

		if(nCaloHits < m_photonMinNHits)
			continue;

		const pandora::Cluster *pCluster = NULL;
		PandoraContentApi::ClusterParameters clusterParameters;
		clusterParameters.m_caloHitList = (*iter).GetCaloHitList();

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(*this, clusterParameters, pCluster));

		clusterVector.push_back(pCluster);
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool PhotonReconstructionAlgorithm::FindInitialShowerPeak(Shower2DHistogram &projectionHistogram, ShowerPeakList &showerPeakList, float &maximumPeakEnergy)
{
	maximumPeakEnergy = 0.f;

	float maximumAvailableEnergy(0.f);
	int maximumBinX(0), maximumBinY(0);

	projectionHistogram.GetMaximumAvailableEnergy(*this, maximumAvailableEnergy, maximumBinX, maximumBinY);

	if(maximumAvailableEnergy < m_photonPeakMinEnergy)
		return false;

	maximumPeakEnergy = maximumAvailableEnergy;

	pandora::CaloHitList peakCaloHitList(projectionHistogram.GetBinAvailableCaloHitList(*this, maximumBinX, maximumBinY));
	ShowerPeak::Bin2D initialBin(maximumBinX, maximumBinY);
	ShowerPeak::Bin2DList binList;
	binList.push_back(initialBin);
	projectionHistogram.SetBinAvailability(maximumBinX, maximumBinY, false);

	ShowerPeak initialShowerPeak(peakCaloHitList, binList, initialBin);
	showerPeakList.push_back(initialShowerPeak);

	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::EnlargePeaks(Shower2DHistogram &projectionHistogram, ShowerPeakList &showerPeakList, float currentEnergyStep)
{
	for(ShowerPeakList::iterator peakIter = showerPeakList.begin(), peakEndIter = showerPeakList.end() ;
			peakEndIter != peakIter ; ++peakIter)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->EnlargePeak(projectionHistogram, *peakIter, currentEnergyStep));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::EnlargePeak(Shower2DHistogram &projectionHistogram, ShowerPeak &showerPeak, float currentEnergyStep)
{
	const ShowerPeak::Bin2DList binList(showerPeak.GetBinList());

	for(ShowerPeak::Bin2DList::const_iterator binIter = binList.begin(), binEndIter = binList.end() ;
			binEndIter != binIter ; ++binIter)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->EnlargePeakAroundBin(projectionHistogram, showerPeak, *binIter, currentEnergyStep));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::EnlargePeakAroundBin(Shower2DHistogram &projectionHistogram, ShowerPeak &showerPeak, const ShowerPeak::Bin2D &bin, float currentEnergyStep)
{
	const int nBinTheta(projectionHistogram.GetNBinsX());
	const int nBinPhi(projectionHistogram.GetNBinsY());

	const int binU(bin.first);
	const int binV(bin.second);

	float energy(projectionHistogram.GetBinAvailableEnergy(*this, binU, binV));

	for(int u=-1 ; u<=1 ; u++)
	{
		for(int v=-1 ; v<=1 ; v++)
		{
			const int thetaBinLookup((binU+u)%nBinTheta);
			const int phiBinLookup((binV+v)%nBinPhi);

			const float lookupEnergy(projectionHistogram.GetBinAvailableEnergy(*this, thetaBinLookup, phiBinLookup));
			const unsigned int nCaloHits(projectionHistogram.GetBinNAvailableCaloHits(*this, thetaBinLookup, phiBinLookup));
			const bool isBinAvailable(projectionHistogram.GetBinAvailability(thetaBinLookup, phiBinLookup));

			if(!isBinAvailable || lookupEnergy > energy || nCaloHits == 0 || lookupEnergy < currentEnergyStep)
				continue;

			ShowerPeak::Bin2D lookupBin(thetaBinLookup, phiBinLookup);

			if(pandora::STATUS_CODE_SUCCESS == showerPeak.AddBin(lookupBin))
			{
				pandora::CaloHitList binCaloHitList(projectionHistogram.GetBinAvailableCaloHitList(*this, thetaBinLookup, phiBinLookup));
				showerPeak.AddCaloHits(binCaloHitList);

				projectionHistogram.SetBinAvailability(thetaBinLookup, phiBinLookup, false);

				PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->EnlargePeakAroundBin(projectionHistogram, showerPeak, lookupBin, currentEnergyStep));
			}
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::FindNewShowerPeaks(Shower2DHistogram &projectionHistogram, ShowerPeakList &showerPeakList, float currentEnergyStep)
{
	while(1)
	{
		float newMaximumAvailableEnergy(0.f);
		int newMaximumBinX(0), newMaximumBinY(0);

		projectionHistogram.GetMaximumAvailableEnergy(*this, newMaximumAvailableEnergy, newMaximumBinX, newMaximumBinY, true);

		// no more peak to create ?
		if(newMaximumAvailableEnergy < m_photonPeakMinEnergy)
			break;

		if(newMaximumAvailableEnergy < currentEnergyStep)
			break;

		pandora::CaloHitList newPeakCaloHitList(projectionHistogram.GetBinAvailableCaloHitList(*this, newMaximumBinX, newMaximumBinY));
		ShowerPeak::Bin2D newBin(newMaximumBinX, newMaximumBinY);
		ShowerPeak::Bin2DList binList;
		binList.push_back(newBin);
		projectionHistogram.SetBinAvailability(newMaximumBinX, newMaximumBinY, false);

		ShowerPeak newShowerPeak(newPeakCaloHitList, binList, newBin);

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->EnlargePeak(projectionHistogram, newShowerPeak, currentEnergyStep));

		showerPeakList.push_back(newShowerPeak);
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::FillProjectionHistogram(const pandora::CaloHitList &caloHitList, Shower2DHistogram &histogram)
{
	for(pandora::CaloHitList::const_iterator iter = caloHitList.begin(), endIter = caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		if(!PandoraContentApi::IsAvailable(*this, pCaloHit))
			continue;

		const pandora::CartesianVector position(pCaloHit->GetPositionVector());
		float radius(0.f), theta(0.f), phi(0.f);

		position.GetSphericalCoordinates(radius, phi, theta);

		if(theta < 0.f)
			std::cout << "Probleme : " << theta << std::endl;

		histogram.Fill(theta, phi, pCaloHit);
	}

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::PerformPhotonPeakLayerClustering(const pandora::CaloHitList &inputCaloHitList, const pandora::CaloHit *const pInputCaloHit, pandora::CaloHitList &usedCaloHitList) const
{
	for(pandora::CaloHitList::const_iterator iter = inputCaloHitList.begin(), endIter = inputCaloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		if(pCaloHit == pInputCaloHit)
			continue;

		if(!PandoraContentApi::IsAvailable(*this, pCaloHit))
			continue;

		if(usedCaloHitList.end() != usedCaloHitList.find(pCaloHit))
			continue;

		const float hitDistance((pCaloHit->GetPositionVector() - pInputCaloHit->GetPositionVector()).GetMagnitude());

		if(hitDistance > m_photonPeakHitMaxDistance)
			continue;

		usedCaloHitList.insert(pCaloHit);

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->PerformPhotonPeakLayerClustering(inputCaloHitList, pCaloHit, usedCaloHitList));
	}

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void PhotonReconstructionAlgorithm::RemoveCaloHitsFromHistogram(const pandora::CaloHitList &caloHitList, Shower2DHistogram &histogram)
{
	for(pandora::CaloHitList::const_iterator iter = caloHitList.begin(), endIter = caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		const pandora::CartesianVector position(pCaloHit->GetPositionVector());
		float radius(0.f), theta(0.f), phi(0.f);

		position.GetSphericalCoordinates(radius, phi, theta);

		const int thetaBin(histogram.GetBinX(theta));
		const int phiBin(histogram.GetBinY(phi));

		if(thetaBin < 0 || phiBin < 0)
		{
			std::cout << "Warning : GetBinX/Y in histogram : theta bin = " << thetaBin << " , phi bin = " << phiBin << std::endl;
			continue;
		}

		pandora::CaloHitList binCaloHitList(histogram.GetBinCaloHitList(thetaBin, phiBin));

		if(!binCaloHitList.erase(pCaloHit))
		{
			std::cout << "Couldn't remove calo hit from histogram : theta/bin , binTheta/binPhi = " <<
					theta << "/" << phi << " , " << thetaBin << "/" << phiBin << std::endl;
			continue;
		}

		histogram.SetBinContent(thetaBin, phiBin, binCaloHitList);
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::RemoveTrackSeededClusters(pandora::ClusterVector &clusterVector)
{
	// Get the current track list to be used as veto
	const pandora::TrackList *pTrackList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pTrackList));

	pandora::TrackVector trackVector(pTrackList->begin(), pTrackList->end());

	const float bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));

	pandora::ClusterVector clusterRemovalList;

	for(pandora::ClusterVector::const_iterator iter = clusterVector.begin(), endIter = clusterVector.end() ; endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster(*iter);

		pandora::CartesianVector clusterCentroid(0.f, 0.f, 0.f);

		if(pandora::STATUS_CODE_SUCCESS != ClusterHelper::GetCentroid(pCluster, clusterCentroid))
			continue;

		for(pandora::TrackVector::const_iterator trackIter = trackVector.begin(), trackEndIter = trackVector.end() ;
				trackEndIter != trackIter ; ++trackIter)
		{
			const pandora::Track *const pTrack(*trackIter);

			const pandora::Helix helix(pTrack->GetTrackStateAtCalorimeter().GetPosition(),
													pTrack->GetTrackStateAtCalorimeter().GetMomentum(), pTrack->GetCharge(), bField);

			pandora::CartesianVector projectionOnHelix(0.f, 0.f, 0.f);

			if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetProjectionOnHelix(helix, clusterCentroid, projectionOnHelix))
				continue;

			const float distanceToHelix((projectionOnHelix-clusterCentroid).GetMagnitude());

			if(distanceToHelix > m_maxTrackClusterDistance)
				continue;

			clusterRemovalList.push_back(pCluster);
			break;
		}
	}

	for(pandora::ClusterVector::const_iterator iter = clusterRemovalList.begin(), endIter = clusterRemovalList.end() ; endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster(*iter);

		for(pandora::ClusterVector::iterator jter = clusterVector.begin(), endJter = clusterVector.end() ; endJter != jter ; ++jter)
		{
			if(*jter == pCluster)
			{
				clusterVector.erase(jter);
				break;
			}
		}

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Delete(*this, pCluster));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::RemoveNearbyTrackCaloHits(pandora::ClusterVector &clusterVector)
{
	// Get the current track list to be used as veto
	const pandora::TrackList *pTrackList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pTrackList));

	pandora::TrackVector trackVector(pTrackList->begin(), pTrackList->end());

	const float bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));

	pandora::ClusterVector clusterRemovalList;

	for(pandora::ClusterVector::const_iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ; clusterEndIter != clusterIter ; ++clusterIter)
	{
		const pandora::Cluster *const pCluster(*clusterIter);

		pandora::CaloHitList clusterCaloHits;
		pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHits);

		pandora::CaloHitList caloHitListRemoval;

		for(pandora::TrackVector::const_iterator trackIter = trackVector.begin(), trackEndIter = trackVector.end() ;
				trackEndIter != trackIter ; ++trackIter)
		{
			const pandora::Track *const pTrack(*trackIter);

			const pandora::Helix helix(pTrack->GetTrackStateAtCalorimeter().GetPosition(),
									pTrack->GetTrackStateAtCalorimeter().GetMomentum(), pTrack->GetCharge(), bField);

			for(pandora::CaloHitList::const_iterator iter = clusterCaloHits.begin(), endIter = clusterCaloHits.end() ;
					endIter != iter ; ++iter)
			{
				const pandora::CaloHit *const pCaloHit(*iter);

				pandora::CartesianVector projectionOnHelix(0.f, 0.f, 0.f);

				if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetProjectionOnHelix(helix, pCaloHit->GetPositionVector(), projectionOnHelix))
						continue;

				const float distanceToHelix((projectionOnHelix-pCaloHit->GetPositionVector()).GetMagnitude());

				if(distanceToHelix > m_photonMaxTrackHitDistance)
					continue;

				caloHitListRemoval.insert(pCaloHit);
			}
		}

		for(pandora::CaloHitList::const_iterator iter = caloHitListRemoval.begin(), endIter = caloHitListRemoval.end() ;
				endIter != iter ; ++iter)
		{
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RemoveFromCluster(*this, pCluster, *iter));
		}

		if(pCluster->GetNCaloHits() < m_photonMinNHits)
		{
			clusterRemovalList.push_back(pCluster);
		}
	}

	for(pandora::ClusterVector::const_iterator iter = clusterRemovalList.begin(), endIter = clusterRemovalList.end() ; endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster(*iter);

		for(pandora::ClusterVector::iterator jter = clusterVector.begin(), endJter = clusterVector.end() ; endJter != jter ; ++jter)
		{
			if(*jter == pCluster)
			{
				clusterVector.erase(jter);
				break;
			}
		}

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Delete(*this, pCluster));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::MergeNearbyCaloHits(const pandora::ClusterVector &clusterVector, const pandora::CaloHitList &inputCaloHitList)
{
	CaloHitToClusterMap caloHitToClusterMap;

	for(pandora::CaloHitList::const_iterator iter = inputCaloHitList.begin(), endIter = inputCaloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		if(!PandoraContentApi::IsAvailable(*this, pCaloHit))
			continue;

		if(!m_shouldUseIsolatedHits && pCaloHit->IsIsolated())
			continue;

		const pandora::CartesianVector &position(pCaloHit->GetPositionVector());
		const pandora::Cluster *pBestCluster = NULL;
		float bestDistanceToCluster(std::numeric_limits<float>::max());

		for(pandora::ClusterVector::const_iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ; clusterEndIter != clusterIter ; ++clusterIter)
		{
			const pandora::Cluster *const pCluster(*clusterIter);

			float distanceToCluster(std::numeric_limits<float>::max());

			if(pandora::STATUS_CODE_SUCCESS != ClusterHelper::GetClosestDistanceApproach(pCluster, position, distanceToCluster))
				continue;

			if(distanceToCluster < m_photonMaxNearbyHitMergingDistance && distanceToCluster < bestDistanceToCluster)
			{
				bestDistanceToCluster = distanceToCluster;
				pBestCluster = pCluster;
			}
		}

		if(NULL != pBestCluster)
		{
			caloHitToClusterMap[pCaloHit] = pBestCluster;
		}
	}

	for(CaloHitToClusterMap::const_iterator iter = caloHitToClusterMap.begin(), endIter = caloHitToClusterMap.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(iter->first);
		const pandora::Cluster *const pCluster(iter->second);

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddToCluster(*this, pCluster, pCaloHit));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::RemovePhotonsUsingParticleId(pandora::ClusterVector &clusterVector)
{
	pandora::ClusterVector clusterRemovalList;

	const pandora::ParticleId *const pParticleId(PandoraContentApi::GetPlugins(*this)->GetParticleId());

	for(pandora::ClusterVector::const_iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ; clusterEndIter != clusterIter ; ++clusterIter)
	{
		const pandora::Cluster *const pCluster(*clusterIter);

		if(!pParticleId->IsPhoton(pCluster))
			clusterRemovalList.push_back(pCluster);
	}

	for(pandora::ClusterVector::const_iterator iter = clusterRemovalList.begin(), endIter = clusterRemovalList.end() ; endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster(*iter);

		for(pandora::ClusterVector::iterator jter = clusterVector.begin(), endJter = clusterVector.end() ; endJter != jter ; ++jter)
		{
			if(*jter == pCluster)
			{
				clusterVector.erase(jter);
				break;
			}
		}

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Delete(*this, pCluster));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::RemoveClustersByProperties(pandora::ClusterVector &clusterVector, pandora::CaloHitList &removalCaloHitList)
{
	pandora::ClusterVector clusterRemovalList;

	std::cout << "RemoveClustersByProperties input n clusters = " << clusterVector.size() << std::endl;

	for(pandora::ClusterVector::const_iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ; clusterEndIter != clusterIter ; ++clusterIter)
	{
		const pandora::Cluster *const pCluster(*clusterIter);

		pandora::CartesianVector clusterCentroid(0.f, 0.f, 0.f);

		if(pandora::STATUS_CODE_SUCCESS != ClusterHelper::GetCentroid(pCluster, clusterCentroid))
			continue;

		std::cout << "Cluster centroid = " << clusterCentroid << std::endl;

		if(2 > pCluster->GetNCaloHits())
		{
			std::cout << "  ===> Less than 2 hits !" << std::endl;
			clusterRemovalList.push_back(pCluster);
			continue;
		}

		ClusterPca clusterPca(pCluster);

//		std::cout << " ==> transverse ratio = " << clusterPca.GetTransverseRatio() << std::endl;

		if(clusterPca.GetTransverseRatio() < m_clusterPropertiesMinTransverseRatio)
		{
			std::cout << "  ===> Transverse ratio cut !" << std::endl;
			clusterRemovalList.push_back(pCluster);
			continue;
		}

		pandora::ClusterFitResult clusterFitResult;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::ClusterFitHelper::FitFullCluster(pCluster, clusterFitResult));

		if(clusterFitResult.IsFitSuccessful())
		{
			const float originAngle(clusterFitResult.GetDirection().GetOpeningAngle(clusterCentroid));

			if(originAngle > m_photonMaxAngleOrigin)
			{
				std::cout << "  ===> Too high angle with origin !" << std::endl;
				clusterRemovalList.push_back(pCluster);
				continue;
			}
		}
		else
		{
			std::cout << "  ===> Fit not successful !" << std::endl;
			clusterRemovalList.push_back(pCluster);
			continue;
		}
	}

	std::cout << "RemoveClustersByProperties will remove : " << clusterRemovalList.size() << " clusters" << std::endl;

	for(pandora::ClusterVector::const_iterator iter = clusterRemovalList.begin(), endIter = clusterRemovalList.end() ; endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster(*iter);

		for(pandora::ClusterVector::const_iterator jter = clusterVector.begin(), endJter = clusterVector.end() ; endJter != jter ; ++jter)
		{
			if(*jter == pCluster)
			{
				clusterVector.erase(jter);
				break;
			}
		}

		pCluster->GetOrderedCaloHitList().GetCaloHitList(removalCaloHitList);

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Delete(*this, pCluster));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::FlagClustersAsPhotons(const pandora::ClusterVector &clusterVector)
{
	for(pandora::ClusterVector::const_iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ; clusterEndIter != clusterIter ; ++clusterIter)
	{
		const pandora::Cluster *const pCluster(*clusterIter);

		PandoraContentApi::ClusterMetadata clusterMetadata;
		clusterMetadata.m_particleId = pandora::PHOTON;

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AlterMetadata(*this, pCluster, clusterMetadata));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_maxCaloHitPseudoLayer = 15;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxCaloHitPseudoLayer", m_maxCaloHitPseudoLayer));

    m_shouldUseIsolatedHits = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ShouldUseIsolatedHits", m_shouldUseIsolatedHits));

    m_projectionNPhiBins = 200;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ProjectionNPhiBins", m_projectionNPhiBins));

    m_projectionNThetaBins = 200;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ProjectionNThetaBins", m_projectionNThetaBins));

    m_photonPeakMinEnergy = 0.01f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonPeakMinEnergy", m_photonPeakMinEnergy));

    m_photonPeakHitMaxDistance = 13.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonPeakHitMaxDistance", m_photonPeakHitMaxDistance));

    m_photonMinNHits = 4;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonMinNHits", m_photonMinNHits));

    m_photonMaxTrackHitDistance = 10.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonMaxTrackHitDistance", m_photonMaxTrackHitDistance));

    m_maxTrackClusterDistance = 20.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxTrackClusterDistance", m_maxTrackClusterDistance));

    m_photonMaxAngleOrigin = 0.523;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonMaxAngleOrigin", m_photonMaxAngleOrigin));

    m_photonMaxNearbyHitMergingDistance = 10.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonMaxNearbyHitMergingDistance", m_photonMaxNearbyHitMergingDistance));

    m_showerPeakNSteps = 200;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ShowerPeakNSteps", m_showerPeakNSteps));

    m_clusterPropertiesMinTransverseRatio = 0.11;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ClusterPropertiesMinTransverseRatio", m_clusterPropertiesMinTransverseRatio));

    return pandora::STATUS_CODE_SUCCESS;
}

}


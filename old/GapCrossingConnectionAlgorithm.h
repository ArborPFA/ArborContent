  /// \file GapCrossingConnectionAlgorithm.h
/*
 *
 * GapCrossingConnectionAlgorithm.h header template automatically generated by a class generator
 * Creation date : jeu. avr. 23 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#ifndef GAPCROSSINGCONNECTIONALGORITHM_H
#define GAPCROSSINGCONNECTIONALGORITHM_H

#include "Pandora/Algorithm.h"
#include "Pandora/PandoraInternal.h"
#include "Helpers/ClusterFitHelper.h"

#include "ArborApi/ArborInputTypes.h"

namespace arbor_content
{

/** 
 *  @brief  GapCrossingConnectionAlgorithm class
 */ 
class GapCrossingConnectionAlgorithm : public pandora::Algorithm
{
public:
	struct GapCrossingInfo
	{
		const pandora::Cluster        *m_pCluster;
		const arbor_content::CaloHit  *m_pCaloHit;
		pandora::ClusterFitResult      m_fitResult;
	};

	typedef std::map<const pandora::CaloHit *, GapCrossingInfo>  GapCrossingInfoMap;

    /**
     *  @brief  Factory class for instantiating algorithm
     */
    class Factory : public pandora::AlgorithmFactory
    {
    public:
        pandora::Algorithm *CreateAlgorithm() const;
    };

private:
    pandora::StatusCode Run();
    pandora::StatusCode ReadSettings(const pandora::TiXmlHandle xmlHandle);

    // TODO to re-implement the algorithm
    /**
     *  @brief  Find hits that are about to cross a gap and will be connected forwardly across the gap
     */
	pandora::StatusCode FindForwardConnectableHits(const pandora::CaloHitList &leafCaloHitList, GapCrossingInfoMap &forwardGapGrossingInfoMap);

	/**
	 *  @brief  Find hits that have just crossed a gap and will be connected backwardly across the gap
	 */
	pandora::StatusCode FindBackwardConnectableHits(const pandora::CaloHitList &seedCaloHitList, GapCrossingInfoMap &backwardGapGrossingInfoMap);

	/**
	 *  @brief  Connect the two seed and leaf calo hit lists across the gaps
	 */
	pandora::StatusCode ConnectCrossGapHits(const GapCrossingInfoMap &forwardGapGrossingInfoMap, const GapCrossingInfoMap &backwardGapGrossingInfoMap);

    /**
//     *  @brief  Find all ecal calo hits eligible for a cross gap connection between clusters
//     *
//     *  @param  pClusterList the ecal cluster list
//     *  @param  gapCrossingInfoMap the map of leaf vs cluster info to fill
//     */
//    pandora::StatusCode FindECalCrossGapConnectCaloHits(const pandora::ClusterList *const pClusterList, GapCrossingInfoMap &gapCrossingInfoMap) const;
//
//    /**
//     *  @brief  Find all hcal calo hits eligible for a cross gap connection between clusters
//     *
//     *  @param  pClusterList the hcal cluster list
//     *  @param  gapCrossingInfoMap the map of seed vs cluster info to fill
//     */
//    pandora::StatusCode FindHCalCrossGapConnectCaloHits(const pandora::ClusterList *const pClusterList, GapCrossingInfoMap &gapCrossingInfoMap) const;
//
//    /**
//     *  @brief  Connect the ecal and hcal clusters
//     *
//     *  @param  ecalGapCrossingInfoMap the ecal leaf vs cluster info map
//     *  @param  hcalGapCrossingInfoMap the ecal seed vs cluster info map
//     *  @param  connectedClusterList the connected cluster list
//     */
//    pandora::StatusCode ConnectGrossGapClusters(const GapCrossingInfoMap &ecalGapCrossingInfoMap, const GapCrossingInfoMap &hcalGapCrossingInfoMap, pandora::ClusterList &connectedClusterList) const;

private:

	float                            m_maxDistanceToDetectorXYEdge;
	float                            m_maxDistanceToDetectorZEdge;
	unsigned int                    m_maxPseudoLayerToEdge;
	std::string                      m_hcalRingDetectorName;

    unsigned int                     m_maxOuterECalLayer;
    unsigned int                     m_maxInnerHCalLayer;
    unsigned int                     m_minECalClusterSize;
    bool                              m_shouldFitECalBranch;
    unsigned int                     m_minECalBranchFitLength;
    unsigned int                     m_minHCalClusterSize;
    unsigned int                     m_maxHCalClusterFitLayers;
    float                             m_crossGapFitAngleDifferenceCut;
    float                             m_crossGapFitAngleDifferenceCut2;
};

//------------------------------------------------------------------------------------------------------------------------------------------

inline pandora::Algorithm *GapCrossingConnectionAlgorithm::Factory::CreateAlgorithm() const
{
    return new GapCrossingConnectionAlgorithm();
}

} 

#endif  //  GAPCROSSINGCONNECTIONALGORITHM_H

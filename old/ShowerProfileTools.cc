  /// \file ShowerProfileTools.cc
/*
 *
 * ShowerProfileTools.cc source template automatically generated by a class generator
 * Creation date : mar. mars 15 2016
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborTools/ShowerProfileTools.h"

#include "ArborHelpers/GeometryHelper.h"

namespace arbor_content
{

pandora::StatusCode SimpleShowerProfileTool::ComputeShowerProfile(const pandora::Cluster *const pCluster, ShowerProfileResult &showerProfileResult)
{
	if( 0 == pCluster->GetNCaloHits() )
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());
	unsigned int showerStartLayer = 0;
	bool showerStartFound = false;
	bool showerOpeningAngleComputed = false;

	for(pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerEndIter = orderedCaloHitList.end() ;
			layerEndIter != layerIter ; ++layerIter)
	{
		const unsigned int pseudoLayer = layerIter->first;

		if( ! showerStartFound )
		{
			showerStartFound = this->IsShowerStartLayer(layerIter, orderedCaloHitList);

			if( showerStartFound )
				showerStartLayer = pseudoLayer;
		}

		if( showerStartFound && ! showerOpeningAngleComputed )
		{
			float openingAngle = this->ComputeShowerOpeningAngle(pCluster, showerStartLayer);
			showerProfileResult.SetShowerOpeningAngle( openingAngle );

			showerOpeningAngleComputed = true;
		}
	}

	if( showerStartFound )
		showerProfileResult.SetShowerStartLayer( showerStartLayer );

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool SimpleShowerProfileTool::IsShowerStartLayer(pandora::OrderedCaloHitList::const_iterator layerIter, const pandora::OrderedCaloHitList &orderedCaloHitList)
{
	if( layerIter == orderedCaloHitList.end() )
		return false;

	bool showerStartFound = true;
	const unsigned int pseudoLayer = layerIter->first;

	for(pandora::OrderedCaloHitList::const_iterator layerIter2 = layerIter ; ; ++layerIter2)
	{
		if( layerIter2 == orderedCaloHitList.end() )
			break;

		const unsigned int pseudoLayer2 = layerIter2->first;

		if( pseudoLayer2 >= pseudoLayer + m_showerStartNextNLayers )
			break;

		if( layerIter2->second->size() < m_showerStartNHitsInLayer)
		{
			showerStartFound = false;
			break;
		}
	}

	return showerStartFound;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float SimpleShowerProfileTool::ComputeShowerOpeningAngle(const pandora::Cluster *const pCluster, unsigned int showerStartLayer)
{
	float openingAngle(0.f);

	const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());
	pandora::OrderedCaloHitList::const_iterator showerStartIter = orderedCaloHitList.find(showerStartLayer);

	if( showerStartIter == orderedCaloHitList.end() )
		return openingAngle;

	pandora::CartesianVector showerStartPoint( pCluster->GetCentroid( showerStartLayer ) );
	unsigned int startFitLayer = showerStartLayer;
	unsigned int endFitLayer = showerStartLayer + m_showerOpeningAngleNextNLayers;
	pandora::ClusterFitResult clusterFitResult;

	pandora::StatusCode statusCode = pandora::ClusterFitHelper::FitLayerCentroids( pCluster , startFitLayer , endFitLayer , clusterFitResult );

	if( statusCode != pandora::STATUS_CODE_SUCCESS || ! clusterFitResult.IsFitSuccessful() )
		return openingAngle;

	pandora::OrderedCaloHitList::const_iterator endFitIter = orderedCaloHitList.find(endFitLayer);

	if( endFitIter == orderedCaloHitList.end() )
		return openingAngle;

	float distanceSum(0.f);
	unsigned int normalization = 0;

	for(pandora::CaloHitList::const_iterator iter = endFitIter->second->begin(), endIter = endFitIter->second->end() ;
			endIter != iter ; ++iter)
	{
		float distance(0.f);

		if( pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetClosestDistanceToLine( showerStartPoint ,
				clusterFitResult.GetDirection() , (*iter)->GetPositionVector() , distance ) )
			continue;

		distanceSum += distance;
		normalization ++;
	}

	if( 0 == normalization )
		return openingAngle;

	pandora::CartesianVector correctedEndLayerCentroid(0.f, 0.f, 0.f);

	if( pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetProjectionOnLine( showerStartPoint ,
			clusterFitResult.GetDirection() , pCluster->GetCentroid( endFitIter->first ) , correctedEndLayerCentroid ) )
		return openingAngle;

	openingAngle = ( ( distanceSum / normalization ) / (showerStartPoint - correctedEndLayerCentroid).GetMagnitude() );

	return openingAngle;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SimpleShowerProfileTool::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_showerStartNextNLayers = 3;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
    		"ShowerStartNextNLayers", m_showerStartNextNLayers));

    m_showerStartNHitsInLayer = 6;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
    		"ShowerStartNHitsInLayer", m_showerStartNHitsInLayer));

    m_showerStartMaxCentroidDistance = 30.f;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
    		"ShowerStartMaxCentroidDistance", m_showerStartMaxCentroidDistance));

	m_showerOpeningAngleNextNLayers = 3;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
    		"ShowerOpeningAngleNextNLayers", m_showerOpeningAngleNextNLayers));

	return pandora::STATUS_CODE_SUCCESS;
}

} 


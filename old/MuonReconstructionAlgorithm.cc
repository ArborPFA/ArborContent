  /// \file MuonReconstructionAlgorithm.cc
/*
 *
 * MuonReconstructionAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. mars 17 2016
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborParticleId/MuonReconstructionAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"

#include "ArborHelpers/CaloHitHelper.h"

namespace arbor_content
{

pandora::StatusCode MuonReconstructionAlgorithm::Run()
{
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->PrepareForClustering());

	const pandora::ClusterList *pMuonClusterList = NULL;
	std::string muonClusterListName;

	// Run clustering algorithm
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunClusteringAlgorithm(*this,
			m_clusteringAlgorithmName, pMuonClusterList, muonClusterListName));

	// Perform track cluster association
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this,
			m_trackClusterAssociationAlgorithmName));

	// analyze clusters and find muons
	pandora::ClusterList filteredMuonClusterList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FilterMuonClusterList(pMuonClusterList, filteredMuonClusterList));

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->CreateMuonPfos(filteredMuonClusterList));

	// tidy up contents
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->TidyUpLists());

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode MuonReconstructionAlgorithm::PrepareForClustering()
{
	const pandora::CaloHitList *pCaloHitList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetList(*this, m_inputCaloHitListName, pCaloHitList));

	const pandora::CaloHitList *pMuonCaloHitList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetList(*this, m_inputMuonCaloHitListName, pMuonCaloHitList));

	pandora::CaloHitList mergedCaloHitList;
	mergedCaloHitList.insert(pCaloHitList->begin(), pCaloHitList->end());
	mergedCaloHitList.insert(pMuonCaloHitList->begin(), pMuonCaloHitList->end());

	// set merged list for muon clustering algorithm
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::SaveList(*this, mergedCaloHitList, m_caloHitClusteringListName));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentList<pandora::CaloHit>(*this, m_caloHitClusteringListName));

	// set track list for muon clustering algorithm
	const pandora::TrackList *pTrackList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetList(*this, m_inputTrackListName, pTrackList));

	pandora::TrackList muonClusteringTrackList;

	for(pandora::TrackList::const_iterator iter = pTrackList->begin(), endIter = pTrackList->end() ;
			endIter != iter ; ++iter)
	{
		const pandora::Track *const pTrack = *iter;

		if( ! pTrack->IsAvailable() )
			continue;

		if( ! pTrack->GetDaughterTrackList().empty() )
			continue;

		if( ! pTrack->ReachesCalorimeter() )
			continue;

		if( pTrack->GetTrackStateAtCalorimeter().GetMomentum().GetMagnitude() < m_minMuonTrackMomentum )
			continue;

		muonClusteringTrackList.insert( pTrack );
	}

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::SaveList(*this, muonClusteringTrackList, m_trackClusteringListName));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentList<pandora::Track>(*this, m_trackClusteringListName));

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode MuonReconstructionAlgorithm::FilterMuonClusterList(const pandora::ClusterList *const pMuonClusterList, pandora::ClusterList &filteredMuonClusterList)
{
	if( pMuonClusterList->empty() )
		return pandora::STATUS_CODE_SUCCESS;

	pandora::ClusterList removeClusterList;

	for(pandora::ClusterList::const_iterator iter = pMuonClusterList->begin(), endIter = pMuonClusterList->end() ;
			endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster = *iter;

		// expect one track per muon cluster
		if( pCluster->GetAssociatedTrackList().size() != 1 )
		{
			removeClusterList.insert( pCluster );
			continue;
		}

		// last layer hit is a muon one ?
		if( pCluster->GetOuterLayerHitType() != pandora::MUON )
		{
			removeClusterList.insert( pCluster );
			continue;
		}

		filteredMuonClusterList.insert( pCluster );
	}

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveClusterConnections(removeClusterList));

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode MuonReconstructionAlgorithm::RemoveClusterConnections(const pandora::ClusterList &clusterList)
{
	if( clusterList.empty() )
		return pandora::STATUS_CODE_SUCCESS;

	pandora::CaloHitList caloHitList;

	for(pandora::ClusterList::const_iterator iter = clusterList.begin(), endIter = clusterList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster = *iter;
		pCluster->GetOrderedCaloHitList().GetCaloHitList(caloHitList);
	}

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::RemoveConnections(&caloHitList));

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode MuonReconstructionAlgorithm::CreateMuonPfos(const pandora::ClusterList &muonClusterList)
{
	const pandora::PfoList *pPfoList = NULL; std::string pfoListName;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::CreateTemporaryListAndSetCurrent(*this, pPfoList, pfoListName));

	for(pandora::ClusterList::const_iterator iter = muonClusterList.begin(), endIter = muonClusterList.end() ;
			endIter != iter ; ++iter)
	{
		PandoraContentApi::ParticleFlowObject::Parameters pfoParameters;

		const pandora::Cluster *const pCluster = *iter;
		pfoParameters.m_clusterList.insert(pCluster);

		const pandora::Track *const pTrack = *pCluster->GetAssociatedTrackList().begin();
		pfoParameters.m_trackList.insert(pTrack);

		// add parent track if any
		const pandora::TrackList &parentTrackList(pTrack->GetParentTrackList());

        if ( ! parentTrackList.empty() )
        {
            pfoParameters.m_trackList.insert(parentTrackList.begin(), parentTrackList.end());
        }

        pfoParameters.m_charge = pTrack->GetCharge();
        pfoParameters.m_momentum = pTrack->GetMomentumAtDca();
        pfoParameters.m_particleId = (pfoParameters.m_charge.Get() > 0) ? pandora::MU_PLUS : pandora::MU_MINUS;
        pfoParameters.m_mass = pandora::PdgTable::GetParticleMass(pfoParameters.m_particleId.Get());
        pfoParameters.m_energy = std::sqrt(pfoParameters.m_mass.Get() * pfoParameters.m_mass.Get() + pfoParameters.m_momentum.Get().GetMagnitudeSquared());

        const pandora::ParticleFlowObject *pPfo(NULL);
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ParticleFlowObject::Create(*this, pfoParameters, pPfo));
	}

	if( ! muonClusterList.empty() && ! pPfoList->empty() )
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::SaveList(*this, m_outputMuonClusterListName, muonClusterList));

		if (m_replaceCurrentClusterList)
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentList<pandora::Cluster>(*this, m_outputMuonClusterListName));

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::SaveList<pandora::Pfo>(*this, m_outputMuonPfoListName));

		if (m_replaceCurrentPfoList)
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentList<pandora::Pfo>(*this, m_outputMuonPfoListName));
	}
	else
	{
		std::cout << "MuonReconstruction: No muon clusters/pfos built !" << std::endl;
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode MuonReconstructionAlgorithm::TidyUpLists()
{
	// tidy up inputs contents
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentList<pandora::CaloHit>(*this, m_caloHitClusteringListName));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::DropCurrentList<pandora::CaloHit>(*this));

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentList<pandora::Track>(*this, m_trackClusteringListName));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::DropCurrentList<pandora::Track>(*this));

	// tidy up output contents
	pandora::CaloHitList pfoCaloHitList; pandora::TrackList pfoTrackList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetPfoComponents(pfoCaloHitList, pfoTrackList));

    // Save the muon-removed track list
    const pandora::TrackList *pInputTrackList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetList(*this, m_inputTrackListName, pInputTrackList));

    pandora::TrackList outputTrackList(*pInputTrackList);

    for (pandora::TrackList::const_iterator iter = pfoTrackList.begin(), iterEnd = pfoTrackList.end(); iter != iterEnd; ++iter)
    {
        outputTrackList.erase(*iter);
    }

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::SaveList(*this, outputTrackList, m_outputTrackListName));
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentList<pandora::Track>(*this, m_replacementTrackListName));

    // Save the muon-removed calo hit list
    const pandora::CaloHitList *pInputCaloHitList = NULL;
    const pandora::CaloHitList *pInputMuonCaloHitList = NULL;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetList(*this, m_inputCaloHitListName, pInputCaloHitList));
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetList(*this, m_inputMuonCaloHitListName, pInputMuonCaloHitList));

    pandora::CaloHitList outputCaloHitList(*pInputCaloHitList);
    pandora::CaloHitList outputMuonCaloHitList(*pInputMuonCaloHitList);

    for (pandora::CaloHitList::const_iterator iter = pfoCaloHitList.begin(), iterEnd = pfoCaloHitList.end(); iter != iterEnd; ++iter)
    {
        outputCaloHitList.erase(*iter);
        outputMuonCaloHitList.erase(*iter);
    }

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::SaveList(*this, outputCaloHitList, m_outputCaloHitListName));
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::SaveList(*this, outputMuonCaloHitList, m_outputMuonCaloHitListName));
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::ReplaceCurrentList<pandora::CaloHit>(*this, m_replacementCaloHitListName));

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode MuonReconstructionAlgorithm::GetPfoComponents(pandora::CaloHitList &pfoCaloHitList, pandora::TrackList &pfoTrackList)
{
    const pandora::PfoList *pPfoList = NULL;
    const pandora::StatusCode statusCode(PandoraContentApi::GetList(*this, m_outputMuonPfoListName, pPfoList));

    if (pandora::STATUS_CODE_NOT_INITIALIZED == statusCode)
        return pandora::STATUS_CODE_SUCCESS;

    if (pandora::STATUS_CODE_SUCCESS != statusCode)
        return statusCode;

    pandora::ClusterList pfoClusterList;

    for (pandora::PfoList::const_iterator iter = pPfoList->begin(), iterEnd = pPfoList->end(); iter != iterEnd; ++iter)
    {
        const pandora::ParticleFlowObject *const pPfo = *iter;
        const int particleId(pPfo->GetParticleId());

        if ((particleId != pandora::MU_MINUS) && (particleId != pandora::MU_PLUS))
            return pandora::STATUS_CODE_FAILURE;

        pfoTrackList.insert(pPfo->GetTrackList().begin(), pPfo->GetTrackList().end());
        pfoClusterList.insert(pPfo->GetClusterList().begin(), pPfo->GetClusterList().end());
    }

    for (pandora::ClusterList::const_iterator iter = pfoClusterList.begin(), iterEnd = pfoClusterList.end(); iter != iterEnd; ++iter)
    {
        const pandora::Cluster *const pCluster = *iter;
        pCluster->GetOrderedCaloHitList().GetCaloHitList(pfoCaloHitList);
        pfoCaloHitList.insert(pCluster->GetIsolatedCaloHitList().begin(), pCluster->GetIsolatedCaloHitList().end());
    }

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode MuonReconstructionAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	// input parameters
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "InputCaloHitListName", m_inputCaloHitListName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "InputMuonCaloHitListName", m_inputMuonCaloHitListName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "InputTrackListName", m_inputTrackListName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "CaloHitClusteringListName", m_caloHitClusteringListName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "TrackClusteringListName", m_trackClusteringListName));

    // algorithms to run
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
        "MuonClusterFormation", m_clusteringAlgorithmName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
        "MuonTrackClusterAssociation", m_trackClusterAssociationAlgorithmName));

    // output parameters
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ReplacementCaloHitListName", m_replacementCaloHitListName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ReplacementTrackListName", m_replacementTrackListName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OutputTrackListName", m_outputTrackListName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OutputCaloHitListName", m_outputCaloHitListName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OutputMuonCaloHitListName", m_outputMuonCaloHitListName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OutputMuonClusterListName", m_outputMuonClusterListName));

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OutputMuonPfoListName", m_outputMuonPfoListName));

    m_replaceCurrentPfoList = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
            "ReplaceCurrentPfoList", m_replaceCurrentPfoList));

    m_replaceCurrentClusterList = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
            "ReplaceCurrentClusterList", m_replaceCurrentClusterList));

    // algorithm parameters
    m_minMuonTrackMomentum = 0.1f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
            "MinMuonTrackMomentum", m_minMuonTrackMomentum));

    return pandora::STATUS_CODE_SUCCESS;
}

} 


/*
 *
 * ConnectorSeedingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 2 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborClustering/ConnectorSeedingAlgorithm.h"
#include "ArborObjects/CaloHit.h"
#include "ArborHelpers/CaloHitHelper.h"
#include "ArborHelpers/GeometryHelper.h"

#include "Pandora/AlgorithmHeaders.h"

#include <sys/time.h>

namespace arbor_content
{

pandora::StatusCode ConnectorSeedingAlgorithm::Run()
{
	const pandora::CaloHitList *pCaloHitList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pCaloHitList));

	if(pCaloHitList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	pandora::OrderedCaloHitList orderedCaloHitList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, orderedCaloHitList.Add(*pCaloHitList));

	// seed with a global distance
	if(0 == m_seedingStrategy)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->Connect(orderedCaloHitList));
	}
	// seed from previous tree structure
	else if(1 == m_seedingStrategy)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->AlignConnectors(orderedCaloHitList));
	}
	// seed using track projections
	else if(2 == m_seedingStrategy)
	{
		const pandora::TrackList *pTrackList = NULL;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pTrackList));

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ConnectFromTracks(orderedCaloHitList, *pTrackList));
	}
	else if(3 == m_seedingStrategy)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->Connect2(orderedCaloHitList));
	}
	else
	{
		return pandora::STATUS_CODE_INVALID_PARAMETER;
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::Connect(const pandora::OrderedCaloHitList &orderedCaloHitList) const
{
	for(pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerEndIter = orderedCaloHitList.end() ;
			layerEndIter != layerIter ; ++layerIter)
	{
		for(pandora::CaloHitList::const_iterator iterI = layerIter->second->begin(), endIterI = layerIter->second->end() ;
				endIterI != iterI ; ++iterI)
		{
			const arbor_content::CaloHit *const pCaloHitI = dynamic_cast<const arbor_content::CaloHit *const>(*iterI);

			if(NULL == pCaloHitI)
				continue;

			// check for availability
			if(m_connectOnlyAvailable && !PandoraContentApi::IsAvailable<pandora::CaloHit>(*this, pCaloHitI))
				continue;

			const unsigned int pseudoLayerI = pCaloHitI->GetPseudoLayer();
			const pandora::CartesianVector &positionVectorI(pCaloHitI->GetPositionVector());
			const pandora::HitType hitTypeI(pCaloHitI->GetHitType());

			for(unsigned int pl = pseudoLayerI+1 ; pl <= pseudoLayerI + m_maxPseudoLayerConnection ; ++pl)
			{
				pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pl);

				if(orderedCaloHitList.end() == findIter)
					continue;

				for(pandora::CaloHitList::const_iterator iterJ = findIter->second->begin(), endIterJ = findIter->second->end() ;
						endIterJ != iterJ ; ++iterJ)
				{
					const arbor_content::CaloHit *const pCaloHitJ = dynamic_cast<const arbor_content::CaloHit *const>(*iterJ);

					if(NULL == pCaloHitJ)
						continue;

					// check for availability
					if(m_connectOnlyAvailable && !PandoraContentApi::IsAvailable<pandora::CaloHit>(*this, pCaloHitJ))
						continue;

					const pandora::CartesianVector &positionVectorJ(pCaloHitJ->GetPositionVector());
					const pandora::HitType hitTypeJ(pCaloHitJ->GetHitType());

					// check types
					if(m_shouldConnectOnlySameHitType && hitTypeI != hitTypeJ)
						continue;

					const float maxConnectionDistance = GetPandora().GetGeometry()->GetHitTypeGranularity(hitTypeJ) <= pandora::FINE ?
							m_maxConnectionDistanceFine : m_maxConnectionDistanceCoarse;
					const float maxConnectionAngle = GetPandora().GetGeometry()->GetHitTypeGranularity(hitTypeJ) <= pandora::FINE ?
							m_maxConnectionAngleFine : m_maxConnectionAngleCoarse;

					const float difference = (positionVectorJ - positionVectorI).GetMagnitude();
					const float angle = (positionVectorJ - positionVectorI).GetOpeningAngle(positionVectorI);

					// check distance
					if(difference > maxConnectionDistance)
						continue;

					// check angle
					if(angle > maxConnectionAngle)
						continue;

					// check if already connected
					if(ArborContentApi::IsConnected(pCaloHitI, pCaloHitJ, FORWARD_DIRECTION))
						continue;

					// connect !
					PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::Connect(pCaloHitI, pCaloHitJ, FORWARD_DIRECTION, maxConnectionDistance));
				}
			}
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::Connect2(const pandora::OrderedCaloHitList &orderedCaloHitList) const
{
	for(pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerEndIter = orderedCaloHitList.end() ;
			layerEndIter != layerIter ; ++layerIter)
	{
		for(pandora::CaloHitList::const_iterator iterI = layerIter->second->begin(), endIterI = layerIter->second->end() ;
				endIterI != iterI ; ++iterI)
		{
			const arbor_content::CaloHit *const pCaloHitI = dynamic_cast<const arbor_content::CaloHit *const>(*iterI);

			if(NULL == pCaloHitI)
				continue;

			// check for availability
			if(m_connectOnlyAvailable && !PandoraContentApi::IsAvailable<pandora::CaloHit>(*this, pCaloHitI))
				continue;

			const unsigned int pseudoLayerI = pCaloHitI->GetPseudoLayer();
			const pandora::CartesianVector &positionVectorI(pCaloHitI->GetPositionVector());
			const pandora::HitType hitTypeI(pCaloHitI->GetHitType());
			const pandora::CartesianVector &cellNormalVector(pCaloHitI->GetCellNormalVector());
			const float normaleAngle = positionVectorI.GetOpeningAngle(cellNormalVector);

			unsigned int start = pseudoLayerI+1;
			unsigned int end = pseudoLayerI + m_maxPseudoLayerConnection;

			for(unsigned int pl = start ; pl <= end ; pl += 1)
			{
				pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pl);

				if(orderedCaloHitList.end() == findIter)
					continue;

				for(pandora::CaloHitList::const_iterator iterJ = findIter->second->begin(), endIterJ = findIter->second->end() ;
						endIterJ != iterJ ; ++iterJ)
				{
					const arbor_content::CaloHit *const pCaloHitJ = dynamic_cast<const arbor_content::CaloHit *const>(*iterJ);

					if(NULL == pCaloHitJ)
						continue;

					// check for availability
					if(m_connectOnlyAvailable && !PandoraContentApi::IsAvailable<pandora::CaloHit>(*this, pCaloHitJ))
						continue;

					const pandora::CartesianVector &positionVectorJ(pCaloHitJ->GetPositionVector());
					const pandora::HitType hitTypeJ(pCaloHitJ->GetHitType());

					// check types
					if(m_shouldConnectOnlySameHitType && hitTypeI != hitTypeJ)
						continue;

					const pandora::Granularity &granularityJ(PandoraContentApi::GetGeometry(*this)->GetHitTypeGranularity(hitTypeJ));

					// TODO include this formula here for the granularity cases !
					// d_i = [ (d_//  - d_perp) / ( pi/2 )  ] * theta_i + d_perp
					const float maxNormaleDistance = granularityJ <= pandora::FINE ?
							m_maxNormaleDistanceFine : m_maxNormaleDistanceCoarse;

					const float maxTransverseDistance = granularityJ <= pandora::FINE ?
							m_maxTransverseDistanceFine : m_maxTransverseDistanceCoarse;

					const float maxDistance = ((maxTransverseDistance - maxNormaleDistance) / M_PI_2 ) * normaleAngle + maxNormaleDistance;

					const float maxConnectionAngle = granularityJ <= pandora::FINE ?
							m_maxConnectionAngleFine : m_maxConnectionAngleCoarse;

					const float difference = (positionVectorJ - positionVectorI).GetMagnitude();
					const float angle = (positionVectorJ - positionVectorI).GetOpeningAngle(positionVectorI);

					// check distance
					if(difference > maxDistance)
						continue;

					// check angle
					if(angle > maxConnectionAngle)
						continue;

					// check if already connected
					if(ArborContentApi::IsConnected(pCaloHitI, pCaloHitJ, FORWARD_DIRECTION))
						continue;

					// connect !
					PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::Connect(pCaloHitI, pCaloHitJ, FORWARD_DIRECTION, maxDistance));
				}
			}
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::AlignConnectors(const pandora::OrderedCaloHitList &orderedCaloHitList) const
{
	ConnectorList connectorToAlignList;

	for(pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerEndIter = orderedCaloHitList.end() ;
			layerEndIter != layerIter ; ++layerIter)
	{
		for(pandora::CaloHitList::const_iterator iter = layerIter->second->begin(), endIter = layerIter->second->end() ;
				endIter != iter ; ++iter)
		{
			const CaloHit *pCaloHit = dynamic_cast<const CaloHit *>(*iter);

			if(NULL == pCaloHit)
				return pandora::STATUS_CODE_FAILURE;

			const ConnectorList &backwardConnectorList(ArborContentApi::GetConnectorList(pCaloHit, BACKWARD_DIRECTION));

			if(!backwardConnectorList.empty())
			{
				connectorToAlignList.insert(backwardConnectorList.begin(), backwardConnectorList.end());
			}
		}
	}

	for(ConnectorList::const_iterator connectorIter = connectorToAlignList.begin(), connectorEndIter = connectorToAlignList.end() ;
			connectorEndIter != connectorIter ; ++connectorIter)
	{
		const Connector *const pConnector = *connectorIter;

		// check for availability
		if(m_connectOnlyAvailable &&
				(!PandoraContentApi::IsAvailable<pandora::CaloHit>(*this, pConnector->GetTo())
						|| !PandoraContentApi::IsAvailable<pandora::CaloHit>(*this, pConnector->GetFrom())))
			continue;

		const pandora::CartesianVector &connectorVector(pConnector->GetVector(FORWARD_DIRECTION));

		float maxConnectionDistance = GetPandora().GetGeometry()->GetHitTypeGranularity(pConnector->GetTo()->GetHitType()) <= pandora::FINE ?
									m_maxConnectionDistanceFine : m_maxConnectionDistanceCoarse;
		float maxConnectionAngle = GetPandora().GetGeometry()->GetHitTypeGranularity(pConnector->GetTo()->GetHitType()) <= pandora::FINE ?
									m_maxConnectionAngleFine : m_maxConnectionAngleCoarse;

		for(unsigned int pl = pConnector->GetTo()->GetPseudoLayer()+1 ; pl <= pConnector->GetTo()->GetPseudoLayer() + m_maxPseudoLayerConnection ; ++pl)
		{
			pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pl);

			if(orderedCaloHitList.end() == findIter)
				continue;

			for(pandora::CaloHitList::const_iterator iter = findIter->second->begin(), endIter = findIter->second->end() ;
					endIter != iter ; ++iter)
			{
				const CaloHit *const pCaloHit = dynamic_cast<const arbor_content::CaloHit *const>(*iter);

				if(NULL == pCaloHit)
					continue;

				// check types
				if(m_shouldConnectOnlySameHitType && pConnector->GetTo()->GetHitType() != pCaloHit->GetHitType())
					continue;

				const pandora::CartesianVector differenceVector(pCaloHit->GetPositionVector() - pConnector->GetTo()->GetPositionVector());

				// cut on distance
				if(differenceVector.GetMagnitude() > maxConnectionDistance)
					continue;

				// cut on angle
				if(maxConnectionAngle > connectorVector.GetOpeningAngle(differenceVector))
					continue;

				// check if already connected
				if(ArborContentApi::IsConnected(pConnector->GetTo(), pCaloHit, FORWARD_DIRECTION))
					continue;

				PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::Connect(pConnector->GetTo(), pCaloHit, FORWARD_DIRECTION, maxConnectionDistance));
			}
		}

		maxConnectionDistance = GetPandora().GetGeometry()->GetHitTypeGranularity(pConnector->GetFrom()->GetHitType()) <= pandora::FINE ?
									m_maxConnectionDistanceFine : m_maxConnectionDistanceCoarse;
		maxConnectionAngle = GetPandora().GetGeometry()->GetHitTypeGranularity(pConnector->GetFrom()->GetHitType()) <= pandora::FINE ?
									m_maxConnectionAngleFine : m_maxConnectionAngleCoarse;

		const unsigned int startPseudoLayer = pConnector->GetFrom()->GetPseudoLayer()-1;
		const unsigned int endPseudoLayer = pConnector->GetFrom()->GetPseudoLayer() <= m_maxPseudoLayerConnection ?
				0 : pConnector->GetFrom()->GetPseudoLayer() - m_maxPseudoLayerConnection;

		for(unsigned int pl = startPseudoLayer ; pl != endPseudoLayer ; --pl)
		{
			pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pl);

			if(orderedCaloHitList.end() == findIter)
				continue;

			for(pandora::CaloHitList::const_iterator iter = findIter->second->begin(), endIter = findIter->second->end() ;
					endIter != iter ; ++iter)
			{
				const CaloHit *const pCaloHit = dynamic_cast<const CaloHit *const>(*iter);

				if(NULL == pCaloHit)
					continue;

				// check types
				if(m_shouldConnectOnlySameHitType && pConnector->GetFrom()->GetHitType() != pCaloHit->GetHitType())
					continue;

				const pandora::CartesianVector differenceVector(pCaloHit->GetPositionVector() - pConnector->GetFrom()->GetPositionVector());

				// cut on distance
				if(differenceVector.GetMagnitude() > maxConnectionDistance)
					continue;

				// cut on angle
				if(maxConnectionAngle > (connectorVector * -1.f).GetOpeningAngle(differenceVector))
					continue;

				// check if already connected
				if(ArborContentApi::IsConnected(pConnector->GetFrom(), pCaloHit, BACKWARD_DIRECTION))
					continue;

				PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::Connect(pConnector->GetFrom(), pCaloHit, BACKWARD_DIRECTION, maxConnectionDistance));
			}
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::ConnectFromTracks(const pandora::OrderedCaloHitList &orderedCaloHitList, const pandora::TrackList &trackList) const
{
	if(trackList.empty() || orderedCaloHitList.empty())
		return pandora::STATUS_CODE_SUCCESS;

	const float bField = this->GetPandora().GetPlugins()->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f));

	for(pandora::TrackList::const_iterator trackIter = trackList.begin(), trackEndIter = trackList.end() ;
			trackEndIter != trackIter ; ++trackIter)
	{
		const pandora::Track *const pTrack  = *trackIter;

		if(!pTrack->IsAvailable() || !pTrack->CanFormPfo() || !pTrack->ReachesCalorimeter())
			continue;

		pandora::CaloHitList seedCaloHitList;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindSeedHits(pTrack, orderedCaloHitList, seedCaloHitList));

		if(seedCaloHitList.empty())
			continue;

		pandora::Helix trackHelix (
				pTrack->GetTrackStateAtCalorimeter().GetPosition(),
				pTrack->GetTrackStateAtCalorimeter().GetMomentum(),
				pTrack->GetCharge(),
				bField
				);

		pandora::CaloHitList connectedCaloHitList;

		for(pandora::CaloHitList::const_iterator iter = seedCaloHitList.begin(), endIter = seedCaloHitList.end() ;
				endIter != iter ; ++iter)
		{
			unsigned int pseudoLayer = (*iter)->GetPseudoLayer();

			pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pseudoLayer);

			if(orderedCaloHitList.end() == findIter)
				continue;

			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ConnectRecursively(*iter, &trackHelix, orderedCaloHitList, findIter, connectedCaloHitList));
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::FindSeedHits(const pandora::Track *const pTrack, const pandora::OrderedCaloHitList &orderedCaloHitList, pandora::CaloHitList &seedCaloHits) const
{
	if(!pTrack->ReachesCalorimeter())
		return pandora::STATUS_CODE_FAILURE;

	// determine the gap size between the tracker and the ecal front face
	float gapSize(0.f);
	pandora::CartesianVector normaleVector(0.f, 0.f, 0.f);

	// end cap case
	if(pTrack->IsProjectedToEndCap())
	{
		normaleVector.SetValues(0.f, 0.f, pTrack->GetTrackStateAtCalorimeter().GetPosition().GetZ() > 0 ? 1.f : -1.f);
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, GeometryHelper::GetTrackerECalEndCapGapSize(this->GetPandora(), gapSize));
	}
	// barrel case
	else
	{
		const unsigned int ecalBarrelInnerSymmetryOrder = this->GetPandora().GetGeometry()->GetSubDetector(pandora::ECAL_BARREL).GetInnerSymmetryOrder();

		const pandora::CartesianVector trackPositionAtCalorimeter = pTrack->GetTrackStateAtCalorimeter().GetPosition();
		const float rTrack = std::sqrt(trackPositionAtCalorimeter.GetX()*trackPositionAtCalorimeter.GetX() + trackPositionAtCalorimeter.GetY()*trackPositionAtCalorimeter.GetY());
		const float phiTrack = trackPositionAtCalorimeter.GetY() > 0 ?
				std::acos(trackPositionAtCalorimeter.GetX() / rTrack) : std::acos(-trackPositionAtCalorimeter.GetX() / rTrack) + M_PI;

		const float phiShift = (2 * M_PI / static_cast<float>(ecalBarrelInnerSymmetryOrder)) / 2.f;

		for(unsigned int i=0 ; i<ecalBarrelInnerSymmetryOrder ; i++)
		{
			const float phi = 2 * M_PI * (static_cast<float>(i) / static_cast<float>(ecalBarrelInnerSymmetryOrder));// + ecalBarrelInnerPhiCoordinate;
			const float phiMin = phi - phiShift;
			const float phiMax = phi + phiShift;

			if(phiTrack > phiMin && phiTrack < phiMax)
			{
				normaleVector.SetValues(-std::sin(phi), std::cos(phi), 0.f);
				break;
			}
		}

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, GeometryHelper::GetTrackerECalBarrelGapSize(this->GetPandora(), gapSize));
	}

	for(unsigned int pseudoLayer = 0 ; pseudoLayer<=m_maxPseudoLayerConnection ; pseudoLayer++)
	{
		pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pseudoLayer);

		if(orderedCaloHitList.end() == findIter)
			continue;

		for(pandora::CaloHitList::const_iterator iter = findIter->second->begin(), endIter = findIter->second->end() ;
				endIter != iter ; ++iter)
		{
			const CaloHit *pCaloHit = dynamic_cast<const arbor_content::CaloHit *>(*iter);

			if(!CaloHitHelper::CanConnect(pTrack, pCaloHit, m_maxNormaleAngleFine, m_maxNormaleDistanceFine, m_maxTransverseAngleFine, m_maxTransverseDistanceFine))
				continue;

			seedCaloHits.insert(pCaloHit);
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//--------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::ConnectRecursively(const pandora::CaloHit *const pCaloHit, const pandora::Helix *const pHelix, const pandora::OrderedCaloHitList &orderedCaloHitList,
		const pandora::OrderedCaloHitList::const_iterator &currentLayerIterator, pandora::CaloHitList &connectedCaloHitList) const
{
	if(NULL == pCaloHit)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	const CaloHit *pCurrentCaloHit = dynamic_cast<const CaloHit*>(pCaloHit);

	pandora::CartesianVector referenceDirection(0.f, 0.f, 0.f);

	if(ArborContentApi::IsSeed(pCurrentCaloHit))
	{
		referenceDirection = pHelix->GetExtrapolatedMomentum(pCurrentCaloHit->GetPositionVector());
	}
	else
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::GetMeanDirection(pCurrentCaloHit, BACKWARD_DIRECTION, referenceDirection, 4));
		referenceDirection = referenceDirection*-1.f;
	}

	const pandora::Granularity granularity = this->GetPandora().GetGeometry()->GetHitTypeGranularity(pCaloHit->GetHitType());

	const float maxNormaleAngle = granularity >= pandora::COARSE ? m_maxNormaleAngleCoarse : m_maxNormaleAngleFine;
	const float maxNormaleDistance = granularity >= pandora::COARSE ? m_maxNormaleDistanceCoarse : m_maxNormaleDistanceFine;
	const float maxTransverseAngle = granularity >= pandora::COARSE ? m_maxTransverseAngleCoarse : m_maxTransverseAngleFine;
	const float maxTransverseDistance = granularity >= pandora::COARSE ? m_maxTransverseDistanceCoarse : m_maxTransverseDistanceFine;

	for(pandora::OrderedCaloHitList::const_iterator iter = currentLayerIterator, endIter = orderedCaloHitList.end() ;
			endIter != iter ; ++iter)
	{
		if(iter->first == pCaloHit->GetPseudoLayer())
			continue;

		if(iter->first - pCaloHit->GetPseudoLayer() > m_maxPseudoLayerConnection)
			break;

		for(pandora::CaloHitList::const_iterator hitIter = iter->second->begin(), hitEndIter = iter->second->end() ;
				hitIter != hitEndIter ; ++hitIter)
		{
			const CaloHit *pForwardCaloHit = dynamic_cast<const CaloHit*>(*hitIter);

			if(ArborContentApi::IsConnected(pCurrentCaloHit, pForwardCaloHit, FORWARD_DIRECTION))
				continue;

			if(!CaloHitHelper::CanConnect(pCurrentCaloHit, pForwardCaloHit, referenceDirection, maxNormaleAngle, maxNormaleDistance, maxTransverseAngle, maxTransverseDistance))
				continue;

			// connect hits
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::Connect(pCurrentCaloHit, pForwardCaloHit, FORWARD_DIRECTION));

//			if(std::find(connectedCaloHitList.begin(), connectedCaloHitList.end(), pForwardCaloHit) != connectedCaloHitList.end())
//				continue;
//
//			connectedCaloHitList.insert(pForwardCaloHit);

			// continue connecting
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ConnectRecursively(pForwardCaloHit, pHelix, orderedCaloHitList, iter, connectedCaloHitList));
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_seedingStrategy = 0;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"SeedingStrategy", m_seedingStrategy));

	m_maxConnectionDistanceFine = 25.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxConnectionDistanceFine", m_maxConnectionDistanceFine));

	m_maxConnectionDistanceCoarse = 45.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxConnectionDistanceCoarse", m_maxConnectionDistanceCoarse));

	m_maxPseudoLayerConnection = 3;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxPseudoLayerConnection", m_maxPseudoLayerConnection));

	m_shouldConnectOnlySameHitType = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"ShouldConnectOnlySameHitType", m_shouldConnectOnlySameHitType));

	m_connectOnlyAvailable = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"ConnectOnlyAvailable", m_connectOnlyAvailable));

	m_maxConnectionAngleFine = M_PI/4.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxConnectionAngleFine", m_maxConnectionAngleFine));

	m_maxConnectionAngleCoarse = M_PI/4.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxConnectionAngleCoarse", m_maxConnectionAngleCoarse));

	//---------------
	m_maxNormaleAngleFine = m_maxConnectionAngleFine;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxNormaleAngleFine", m_maxNormaleAngleFine));

	m_maxNormaleAngleCoarse = m_maxConnectionAngleCoarse;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxNormaleAngleCoarse", m_maxNormaleAngleCoarse));

	m_maxTransverseAngleFine = .1f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxTransverseAngleFine", m_maxTransverseAngleFine));

	m_maxTransverseAngleCoarse = .2f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxTransverseAngleCoarse", m_maxTransverseAngleCoarse));

	//---------------
	m_maxNormaleDistanceFine = m_maxConnectionDistanceFine;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxNormaleDistanceFine", m_maxNormaleDistanceFine));

	m_maxNormaleDistanceCoarse = m_maxConnectionDistanceCoarse;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxNormaleDistanceCoarse", m_maxNormaleDistanceCoarse));

	m_maxTransverseDistanceFine = m_maxNormaleDistanceFine*2.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxTransverseDistanceFine", m_maxTransverseDistanceFine));

	m_maxTransverseDistanceCoarse = m_maxNormaleDistanceCoarse*2.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxTransverseDistanceCoarse", m_maxTransverseDistanceCoarse));

	return pandora::STATUS_CODE_SUCCESS;
}

}


  /// \file GapCrossingConnectionAlgorithm.cc
/*
 *
 * GapCrossingConnectionAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 23 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborClustering/GapCrossingConnectionAlgorithm.h"
#include "ArborObjects/CaloHit.h"
#include "ArborHelpers/CaloHitHelper.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ReclusterHelper.h"
#include "ArborHelpers/ClusterHelper.h"

#include "Pandora/AlgorithmHeaders.h"
#include "Helpers/ClusterFitHelper.h"

namespace arbor_content
{

pandora::StatusCode GapCrossingConnectionAlgorithm::Run()
{
	const pandora::CaloHitList *pCaloHitList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pCaloHitList));

	pandora::CaloHitList leafCaloHitList;
	pandora::CaloHitList seedCaloHitList;

	// Find all leaves and seeds. Discriminate hits that are seeds and leaves at the same time
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::ExtractLeafCaloHitList(pCaloHitList, leafCaloHitList, false));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::ExtractSeedCaloHitList(pCaloHitList, seedCaloHitList, false));

	std::cout << "leafCaloHitList.size() : " << leafCaloHitList.size() << std::endl;
	std::cout << "seedCaloHitList.size() : " << seedCaloHitList.size() << std::endl;

	GapCrossingInfoMap forwardGapGrossingInfoMap;
	GapCrossingInfoMap backwardGapGrossingInfoMap;

	// Find connectable hits that are about to cross a gap or has just crossed a gap
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindForwardConnectableHits(leafCaloHitList, forwardGapGrossingInfoMap));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindBackwardConnectableHits(seedCaloHitList, backwardGapGrossingInfoMap));

	std::cout << "forwardGapGrossingInfoMap.size() : " << forwardGapGrossingInfoMap.size() << std::endl;
	std::cout << "backwardGapGrossingInfoMap.size() : " << backwardGapGrossingInfoMap.size() << std::endl;

	// Connect the two lists together
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ConnectCrossGapHits(forwardGapGrossingInfoMap, backwardGapGrossingInfoMap));

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

// leaving clusters !
pandora::StatusCode GapCrossingConnectionAlgorithm::FindForwardConnectableHits(const pandora::CaloHitList &leafCaloHitList, GapCrossingInfoMap &forwardGapGrossingInfoMap)
{
	const float ecalBarrelOuterRCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::ECAL_BARREL).GetOuterRCoordinate();
	const float ecalBarrelOuterZCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::ECAL_BARREL).GetOuterZCoordinate();
	const float hcalBarrelOuterZCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::HCAL_BARREL).GetOuterZCoordinate();
	const float hcalEndcapInnerZCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::HCAL_ENDCAP).GetInnerZCoordinate();
	const float ecalEndcapOuterZCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::ECAL_ENDCAP).GetOuterZCoordinate();

	float hcalRingOuterZCoordinate(std::numeric_limits<float>::max());

	if(!m_hcalRingDetectorName.empty())
	{
		hcalRingOuterZCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(m_hcalRingDetectorName).GetOuterZCoordinate();
	}

	const unsigned int lastECalBarrelPseudoLayer = PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->GetPseudoLayer(pandora::CartesianVector(0.f, ecalBarrelOuterRCoordinate, 0.f));
//	const unsigned int lastECalEndcapPseudoLayer = PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->GetPseudoLayer(pandora::CartesianVector(0.f, 0.f, ecalEndcapOuterZCoordinate));

	for(pandora::CaloHitList::const_iterator iter = leafCaloHitList.begin() , endIter = leafCaloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const arbor_content::CaloHit *const pCaloHit = dynamic_cast<const arbor_content::CaloHit *const>(*iter);

		if(NULL == pCaloHit)
			continue;

		const pandora::HitRegion hitRegion(pCaloHit->GetHitRegion());
		const pandora::HitType hitType(pCaloHit->GetHitType());

		// TODO handle leaving region 5

		if(hitRegion == pandora::BARREL && hitType == pandora::ECAL)
		{
			if(lastECalBarrelPseudoLayer - pCaloHit->GetPseudoLayer() > m_maxPseudoLayerToEdge
			&& ecalBarrelOuterZCoordinate - fabs(pCaloHit->GetPositionVector().GetZ()) > m_maxDistanceToDetectorZEdge)
				continue;
		}
		else if(hitRegion == pandora::ENDCAP && hitType == pandora::ECAL)
		{
			if(ecalEndcapOuterZCoordinate - fabs(pCaloHit->GetPositionVector().GetZ()) > m_maxDistanceToDetectorZEdge
			&& !pCaloHit->IsInOuterSamplingLayer())
				continue;
		}
		else if(hitRegion == pandora::BARREL && hitType == pandora::HCAL)
		{
			if(hcalBarrelOuterZCoordinate - fabs(pCaloHit->GetPositionVector().GetZ()) > m_maxDistanceToDetectorZEdge)
				continue;
		}
		else if(hitRegion == pandora::ENDCAP && hitType == pandora::HCAL)
		{
			// HCal ring case !
			if(fabs(pCaloHit->GetPositionVector().GetZ()) > ecalBarrelOuterZCoordinate
			&& fabs(pCaloHit->GetPositionVector().GetZ()) < hcalEndcapInnerZCoordinate
			&& !m_hcalRingDetectorName.empty()) // hcal ring detector geo key specified
			{
				// Am i leaving the hcal ring ?
				if(hcalRingOuterZCoordinate - fabs(pCaloHit->GetPositionVector().GetZ()) >  m_maxDistanceToDetectorZEdge)
					continue;
			}
		}
		// unknown hit or out of purpose of this function
		else
			continue;

		pandora::ClusterFitResult fitResult;
		pandora::ClusterFitPointList clusterFitPointList;
		pandora::CaloHitList fitCaloHits;
		fitCaloHits.insert(pCaloHit);

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::BuildCaloHitList(pCaloHit, BACKWARD_DIRECTION, fitCaloHits, m_minECalBranchFitLength, std::numeric_limits<unsigned int>::max()));

		if(fitCaloHits.size() < m_minECalBranchFitLength)
			continue;

		for(pandora::CaloHitList::iterator fitHitIter = fitCaloHits.begin(), fitHitEndIter = fitCaloHits.end() ;
				fitHitEndIter != fitHitIter ; ++fitHitIter)
			clusterFitPointList.push_back(pandora::ClusterFitPoint(*fitHitIter));

		pandora::StatusCode statusCode = pandora::ClusterFitHelper::FitPoints(clusterFitPointList, fitResult);

		if(statusCode != pandora::STATUS_CODE_SUCCESS || !fitResult.IsFitSuccessful())
			continue;

		forwardGapGrossingInfoMap[pCaloHit].m_pCaloHit = pCaloHit;
		forwardGapGrossingInfoMap[pCaloHit].m_fitResult = fitResult;
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

// entering clusters !!
pandora::StatusCode GapCrossingConnectionAlgorithm::FindBackwardConnectableHits(const pandora::CaloHitList &seedCaloHitList, GapCrossingInfoMap &backwardGapGrossingInfoMap)
{
//	const float hcalBarrelInnerRCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::HCAL_BARREL).GetInnerRCoordinate();
//	const float hcalEndcapInnerZCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::HCAL_ENDCAP).GetInnerZCoordinate();
//	const float ecalBarrelInnerRCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::ECAL_BARREL).GetInnerRCoordinate();

//	const unsigned int firstHCalBarrelPseudoLayer = PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->GetPseudoLayer(pandora::CartesianVector(0.f, hcalBarrelInnerRCoordinate, 0.f));
//	const unsigned int firstHCalEndcapPseudoLayer = PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->GetPseudoLayer(pandora::CartesianVector(0.f, 0.f, hcalEndcapInnerZCoordinate));

	for(pandora::CaloHitList::const_iterator iter = seedCaloHitList.begin() , endIter = seedCaloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const arbor_content::CaloHit *const pCaloHit = dynamic_cast<const arbor_content::CaloHit *const>(*iter);

		if(NULL == pCaloHit)
			continue;

		const pandora::HitRegion hitRegion(pCaloHit->GetHitRegion());
		const pandora::HitType hitType(pCaloHit->GetHitType());

		// TODO handle entering region 4 and 5

		// hcal barrel, ring and endcap handling
		if((hitRegion == pandora::ENDCAP || hitRegion == pandora::BARREL ) && hitType == pandora::HCAL)
		{
			if(pCaloHit->GetLayer() > m_maxPseudoLayerToEdge)
				continue;
		}
		else if(hitRegion == pandora::ENDCAP && hitType == pandora::ECAL)
		{
			if(pCaloHit->GetLayer() > m_maxPseudoLayerToEdge)
//			||Â pCaloHit->GetPositionVector().GetZ())
				continue;
		}
		// unknown hit or out of the scope of this function
		else
			continue;

		pandora::CaloHitList treeFitCaloHitList;
		treeFitCaloHitList.insert(pCaloHit);
		pandora::ClusterFitPointList fitPointList;
		pandora::ClusterFitResult fitResult;

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::BuildCaloHitList(pCaloHit, FORWARD_DIRECTION, treeFitCaloHitList, m_maxHCalClusterFitLayers, std::numeric_limits<float>::max()));

		if(treeFitCaloHitList.size() < m_minHCalClusterSize)
			continue;

		for(pandora::CaloHitList::const_iterator fitHitIter = treeFitCaloHitList.begin(), fitHitEndIter = treeFitCaloHitList.end() ;
				fitHitEndIter != fitHitIter ; ++fitHitIter)
			fitPointList.push_back(pandora::ClusterFitPoint(*fitHitIter));

		const pandora::StatusCode statusCode = pandora::ClusterFitHelper::FitPoints(fitPointList, fitResult);

		if(statusCode != pandora::STATUS_CODE_SUCCESS || !fitResult.IsFitSuccessful())
			continue;

		backwardGapGrossingInfoMap[pCaloHit].m_pCaloHit = pCaloHit;
		backwardGapGrossingInfoMap[pCaloHit].m_fitResult = fitResult;
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode GapCrossingConnectionAlgorithm::ConnectCrossGapHits(const GapCrossingInfoMap &forwardGapGrossingInfoMap, const GapCrossingInfoMap &backwardGapGrossingInfoMap)
{
	for(GapCrossingInfoMap::const_iterator hcalIter = backwardGapGrossingInfoMap.begin(), hcalEndIter = backwardGapGrossingInfoMap.end() ;
			hcalEndIter != hcalIter ; ++hcalIter)
	{
		const arbor_content::CaloHit *pHCalSeedCaloHit = hcalIter->second.m_pCaloHit;

		GapCrossingInfoMap::const_iterator bestCompatibleConnection = forwardGapGrossingInfoMap.end();
		float bestChi2 = std::numeric_limits<float>::max();

		for(GapCrossingInfoMap::const_iterator ecalIter = forwardGapGrossingInfoMap.begin(), ecalEndIter = forwardGapGrossingInfoMap.end() ;
				ecalEndIter != ecalIter ; ++ecalIter)
		{
			if(hcalIter->first->GetHitRegion() != ecalIter->first->GetHitRegion())
				continue;

			const pandora::CartesianVector ecalFitDirection(ecalIter->second.m_fitResult.GetDirection());

			const float fitAngleDifference = ecalFitDirection.GetOpeningAngle(hcalIter->first->GetPositionVector() - ecalIter->first->GetPositionVector());
			const float fitAngleDifference2 = ecalFitDirection.GetOpeningAngle(hcalIter->second.m_fitResult.GetDirection());
			const float normalizedFitAngle = fitAngleDifference/m_crossGapFitAngleDifferenceCut;
			const float normalizedFitAngle2 = fitAngleDifference2/m_crossGapFitAngleDifferenceCut2;

			if(normalizedFitAngle >= 1.f)// || normalizedFitAngle2 >= 1.f)
				continue;

			const float chi2 = normalizedFitAngle*normalizedFitAngle + normalizedFitAngle2*normalizedFitAngle2;

			if(bestChi2 > chi2)
			{
				bestChi2 = chi2;
				bestCompatibleConnection = ecalIter;
			}
		}

		if(bestCompatibleConnection == forwardGapGrossingInfoMap.end())
			continue;

		const arbor_content::CaloHit *pECalLeafCaloHit = bestCompatibleConnection->second.m_pCaloHit;
		const float connectorNormalization = (pECalLeafCaloHit->GetPositionVector() - pHCalSeedCaloHit->GetPositionVector()).GetMagnitude();

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::Connect(pECalLeafCaloHit, pHCalSeedCaloHit, FORWARD_DIRECTION, connectorNormalization));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode GapCrossingConnectionAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_maxDistanceToDetectorXYEdge = 25.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxDistanceToDetectorXYEdge", m_maxDistanceToDetectorXYEdge));

	m_maxDistanceToDetectorZEdge = 25.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxDistanceToDetectorZEdge", m_maxDistanceToDetectorZEdge));

	m_maxPseudoLayerToEdge = 2;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxPseudoLayerToEdge", m_maxPseudoLayerToEdge));

	m_hcalRingDetectorName = "";
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"HCalRingDetectorName", m_hcalRingDetectorName));



	m_maxOuterECalLayer = 2;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxOuterECalLayer", m_maxOuterECalLayer));

	m_maxInnerHCalLayer = 2;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxInnerHCalLayer", m_maxInnerHCalLayer));

	m_minECalClusterSize = 3;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MinECalClusterSize", m_minECalClusterSize));

	m_minHCalClusterSize = 3;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MinHCalClusterSize", m_minHCalClusterSize));

    m_shouldFitECalBranch = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"ShouldFitECalBranch", m_shouldFitECalBranch));

	if(m_shouldFitECalBranch)
	{
		m_minECalBranchFitLength = 4;
		PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
				"MinECalBranchFitLength", m_minECalBranchFitLength));
	}

	m_maxHCalClusterFitLayers = 4;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxHCalClusterFitLayers", m_maxHCalClusterFitLayers));

    m_crossGapFitAngleDifferenceCut = M_PI/12.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        	"CrossGapFitAngleDifferenceCut", m_crossGapFitAngleDifferenceCut));

    m_crossGapFitAngleDifferenceCut2 = M_PI/12.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        	"CrossGapFitAngleDifferenceCut2", m_crossGapFitAngleDifferenceCut2));

	return pandora::STATUS_CODE_SUCCESS;
}

} 

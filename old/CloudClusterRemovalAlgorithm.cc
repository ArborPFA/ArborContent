  /// \file CloudClusterRemovalAlgorithm.cc
/*
 *
 * CloudClusterRemovalAlgorithm.cc source template automatically generated by a class generator
 * Creation date : lun. nov. 30 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborTopologicalAssociation/CloudClusterRemovalAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"
#include "ArborHelpers/ClusterHelper.h"
#include "ArborObjects/CaloHit.h"

namespace arbor_content
{

pandora::StatusCode CloudClusterRemovalAlgorithm::Run()
{
	const pandora::ClusterList *pClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	if(pClusterList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	pandora::ClusterVector clusterVector;
	pandora::CaloHitList connectorRemovalCaloHitList;

	for(pandora::ClusterList::const_iterator iter = pClusterList->begin(), endIter = pClusterList->end() ;
			endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster = *iter;

		if(!pCluster->GetAssociatedTrackList().empty())
			continue;

		// initial cuts on cluster size
		if(m_maxClusterNHit > pCluster->GetNCaloHits())
		{
			pCluster->GetOrderedCaloHitList().GetCaloHitList(connectorRemovalCaloHitList);
			clusterVector.push_back(pCluster);
			continue;
		}

		if(m_maxClusterNHit2 < pCluster->GetNCaloHits())
			continue;

		// first check for cluster energy
		float clusterEnergy(0.f);

		if(PandoraContentApi::GetPlugins(*this)->GetParticleId()->IsEmShower(pCluster))
		{
			clusterEnergy = pCluster->GetCorrectedElectromagneticEnergy(this->GetPandora());
		}
		else
		{
			clusterEnergy = pCluster->GetCorrectedHadronicEnergy(this->GetPandora());
		}

		if(clusterEnergy > m_maxClusterEnergy)
			continue;

		float clusterExtension(0.f);

		pandora::CaloHitList clusterCaloHits;
		pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHits);

		for(pandora::CaloHitList::const_iterator cIter = clusterCaloHits.begin(), cEndIter = clusterCaloHits.end() ;
				cEndIter != cIter ; ++cIter)
		{
			for(pandora::CaloHitList::const_iterator cIter2 = cIter, cEndIter2 = clusterCaloHits.end() ;
					cEndIter2 != cIter2 ; ++cIter2)
			{
				if(*cIter == *cIter2)
					continue;

				clusterExtension += ((*cIter)->GetPositionVector() - (*cIter2)->GetPositionVector()).GetMagnitude();
			}
		}

		clusterExtension /= (clusterCaloHits.size() * clusterCaloHits.size());

		if(clusterExtension < m_minClusterExtension)
			continue;

		pCluster->GetOrderedCaloHitList().GetCaloHitList(connectorRemovalCaloHitList);
		clusterVector.push_back(pCluster);
	}

	for(pandora::CaloHitList::const_iterator iter = connectorRemovalCaloHitList.begin(), endIter = connectorRemovalCaloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const arbor_content::CaloHit *const pCaloHit = dynamic_cast<const arbor_content::CaloHit *const>(*iter);

		if(NULL == pCaloHit)
			continue;

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::RemoveAndDeleteAllConnections(pCaloHit));
	}

	for(pandora::ClusterVector::iterator iter = clusterVector.begin(), endIter = clusterVector.end() ;
			endIter != iter ; ++iter)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Delete<pandora::Cluster>(*this, *iter));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CloudClusterRemovalAlgorithm::GetClusterExtension(const pandora::Cluster *const pCluster, pandora::CartesianVector &extension) const
{
	if(0 == pCluster->GetNCaloHits())
		return pandora::STATUS_CODE_FAILURE;

	pandora::CartesianVector clusterCentroid(0.f, 0.f, 0.f);
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, clusterCentroid));

	pandora::CaloHitList clusterCaloHitList;
	pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHitList);

	float extensionX(0.f);
	float extensionY(0.f);
	float extensionZ(0.f);

	for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit = *iter;

		const float distanceX = pCaloHit->GetPositionVector().GetX() - clusterCentroid.GetX();
		const float distanceY = pCaloHit->GetPositionVector().GetY() - clusterCentroid.GetY();
		const float distanceZ = pCaloHit->GetPositionVector().GetZ() - clusterCentroid.GetZ();

		extensionX += distanceX*distanceX;
		extensionY += distanceY*distanceY;
		extensionZ += distanceZ*distanceZ;
	}

	extensionX /= (pCluster->GetNCaloHits()*pCluster->GetNCaloHits());
	extensionY /= (pCluster->GetNCaloHits()*pCluster->GetNCaloHits());
	extensionZ /= (pCluster->GetNCaloHits()*pCluster->GetNCaloHits());

	try
	{
		extension.SetValues(extensionX, extensionY, extensionZ);
		extension *= (1.f / (pCluster->GetNCaloHits()*pCluster->GetNCaloHits()));
	}
	catch(const pandora::StatusCodeException &exception)
	{
		return exception.GetStatusCode();
	}


	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CloudClusterRemovalAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_maxClusterEnergy = 1.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "MaxClusterEnergy", m_maxClusterEnergy));

	m_maxClusterNHit = 5;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "MaxClusterNHit", m_maxClusterNHit));

	m_maxClusterNHit2 = 20;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "MaxClusterNHit2", m_maxClusterNHit2));

	m_minClusterExtension = 15.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "MinClusterExtension", m_minClusterExtension));

	return pandora::STATUS_CODE_SUCCESS;
}

} 


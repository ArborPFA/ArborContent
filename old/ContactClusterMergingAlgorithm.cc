  /// \file ContactClusterMergingAlgorithm.cc
/*
 *
 * ContactClusterMergingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : lun. dï¿½c. 7 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborTopologicalAssociation/ContactClusterMergingAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"

#include "ArborHelpers/ClusterHelper.h"
#include "ArborHelpers/ReclusterHelper.h"

namespace arbor_content
{

pandora::StatusCode ContactClusterMergingAlgorithm::Run()
{
	// get current cluster list
	const pandora::ClusterList *pClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	if(pClusterList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	pandora::ClusterVector clusterVector(pClusterList->begin(), pClusterList->end());

	for(pandora::ClusterVector::iterator iIter = clusterVector.begin(), iEndIter = clusterVector.end() ;
			iEndIter != iIter ; ++iIter)
	{
		const pandora::Cluster *const pParentCluster = *iIter;

		if(NULL == pParentCluster)
			continue;

		if(pParentCluster->GetAssociatedTrackList().empty())
			continue;

		std::cout << "Cluster with track p = " << (*pParentCluster->GetAssociatedTrackList().begin())->GetEnergyAtDca() << " GeV" << std::endl;

		bool contactClusterFound = true;

		while(contactClusterFound)
		{
			contactClusterFound = false;

			for(pandora::ClusterVector::iterator jIter = clusterVector.begin(), jEndIter = clusterVector.end() ;
					jEndIter != jIter ; ++jIter)
			{
				const pandora::Cluster *const pDaughterCluster = *jIter;

				if(NULL == pDaughterCluster)
					continue;

				if(pDaughterCluster == pParentCluster)
					continue;

				if(!pDaughterCluster->GetAssociatedTrackList().empty())
					continue;

				std::cout << " ==> Checking for close contact with " << pDaughterCluster->GetCorrectedHadronicEnergy(this->GetPandora()) << std::endl;

				if(this->AreClustersInCloseContact(pParentCluster, pDaughterCluster))
				{
					const pandora::TrackList &trackList(pParentCluster->GetAssociatedTrackList());
					float trackEnergySum(0.f);

					std::cout << " ==> ** !!! Close contact !!! **" << std::endl;

				    for (pandora::TrackList::const_iterator trackIter = trackList.begin(), trackIterEnd = trackList.end() ;
				    		trackIter != trackIterEnd; ++trackIter)
				        trackEnergySum += (*trackIter)->GetEnergyAtDca();

				    const float parentClusterEnergy = pParentCluster->GetTrackComparisonEnergy(this->GetPandora());
				    const float clusterEnergySum = parentClusterEnergy + pDaughterCluster->GetTrackComparisonEnergy(this->GetPandora());

				    const float oldChi = ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), parentClusterEnergy, trackEnergySum);
				    const float newChi = ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), clusterEnergySum, trackEnergySum);

				    const bool improvesCompatibility = newChi*newChi < oldChi*oldChi || newChi*newChi < m_maxEnergyChi2;

				    if(improvesCompatibility)
				    {
				    	std::cout << " ==> ** !!! Merging !!! **" << std::endl;

						// merge clusters
						PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::MergeAndDeleteClusters(*this, pParentCluster, pDaughterCluster));

						// clean iterator for next iterations
						(*jIter) = NULL;

						// break the loop and restart it
						contactClusterFound = true;
						break;
				    }
				}
			}
		}



	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool ContactClusterMergingAlgorithm::AreClustersInCloseContact(const pandora::Cluster *const pParentCluster, const pandora::Cluster *const pDaughterCluster) const
{
	if(NULL == pParentCluster || NULL == pDaughterCluster)
		return false;

	try
	{
//		pandora::CartesianVector parentCentroid(0.f, 0.f, 0.f);
//		pandora::CartesianVector daughterCentroid(0.f, 0.f, 0.f);
//
//		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pParentCluster, parentCentroid));
//		PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pDaughterCluster, daughterCentroid));

//		const float clusterDistance = (parentCentroid - daughterCentroid).GetMagnitude();

		// check cluster separation distance as first evidence of close contact
//		if(clusterDistance > m_maxClusterDistance)
//			return false;

		pandora::CaloHitList parentClusterHits;
		pandora::CaloHitList daughterClusterHits;
		unsigned int nContactCaloHits = 0;

		pParentCluster->GetOrderedCaloHitList().GetCaloHitList(parentClusterHits);
		pDaughterCluster->GetOrderedCaloHitList().GetCaloHitList(daughterClusterHits);

		for(pandora::CaloHitList::const_iterator pIter = parentClusterHits.begin(), pEndIter = parentClusterHits.end() ;
				pEndIter != pIter ; ++pIter)
		{
			const pandora::CaloHit *const pParentCaloHit = *pIter;
			pandora::Granularity granularity(PandoraContentApi::GetGeometry(*this)->GetHitTypeGranularity(pParentCaloHit->GetHitType()));
			const float minClusterContactDistance(granularity > pandora::FINE ? m_minClusterContactDistanceCoarse : m_minClusterContactDistanceFine);

			for(pandora::CaloHitList::const_iterator dIter = daughterClusterHits.begin(), dEndIter = daughterClusterHits.end() ;
					dEndIter != dIter ; ++dIter)
			{
				const pandora::CaloHit *const pDaughterCaloHit = *dIter;

				if((pDaughterCaloHit->GetPositionVector() - pParentCaloHit->GetPositionVector()).GetMagnitude() < minClusterContactDistance)
				{
					nContactCaloHits++;
					break; // avoid double counting ...
				}
			}
		}

		std::cout << "nContactCaloHits : " << nContactCaloHits << std::endl;

		if(nContactCaloHits > m_minNHitContact)
		{
			return true;
		}
	}
	catch(const pandora::StatusCodeException &/*exception*/)
	{
		return false;
	}

	return false;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ContactClusterMergingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_maxClusterDistance = 50.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxClusterDistance", m_maxClusterDistance));

	m_minClusterContactDistanceFine = 10.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MinClusterContactDistanceFine", m_minClusterContactDistanceFine));

	m_minClusterContactDistanceCoarse = 20.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MinClusterContactDistanceCoarse", m_minClusterContactDistanceCoarse));

	m_minNHitContact = 10;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MinNHitContact", m_minNHitContact));

	m_maxEnergyChi2 = 1.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxEnergyChi2", m_maxEnergyChi2));

	return pandora::STATUS_CODE_SUCCESS;
}


} 


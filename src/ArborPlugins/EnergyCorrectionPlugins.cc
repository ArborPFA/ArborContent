/// \file EnergyCorrectionPlugin.cc
/*
 *
 * EnergyCorrectionPlugin.cc source template automatically generated by a class generator
 * Creation date : mar. nov. 17 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborPlugins/EnergyCorrectionPlugins.h"
#include "ArborHelpers/ClusterHelper.h"
#include "ArborPlugins/ParticleIdPlugins.h"

#include "Pandora/AlgorithmHeaders.h"

namespace arbor_content
{
  AnalogicEnergyFunction::AnalogicEnergyFunction() :
        m_ecalEnergyType(0),
        m_hcalEnergyType(0),
        m_muonEnergyType(0),
        m_otherEnergyType(0)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode AnalogicEnergyFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHitList);

    correctedEnergy = 0.f;

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit = *iter;

      const pandora::HitType hitType(pCaloHit->GetHitType());

      const unsigned int energyType(
          (hitType == pandora::ECAL) ? m_ecalEnergyType :
              (hitType == pandora::HCAL) ? m_hcalEnergyType :
                  (hitType == pandora::MUON) ? m_muonEnergyType :
                      m_otherEnergyType);

      switch(energyType)
      {
      case 0:
        correctedEnergy += pCaloHit->GetInputEnergy();
        break;
      case 1:
        correctedEnergy += pCaloHit->GetElectromagneticEnergy();
        break;
      case 2:
        correctedEnergy += pCaloHit->GetHadronicEnergy();
        break;
      default:
        correctedEnergy += pCaloHit->GetInputEnergy();
        break;
      }
    }

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode AnalogicEnergyFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    m_ecalEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalEnergyType", m_ecalEnergyType));

    m_hcalEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalEnergyType", m_hcalEnergyType));

    m_muonEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MuonEnergyType", m_muonEnergyType));

    m_otherEnergyType = 0;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "OtherEnergyType", m_otherEnergyType));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  SdhcalQuadraticEnergyFunction::SdhcalQuadraticEnergyFunction()
  {
    m_energyConstantParameters.push_back(0.0385315);
    m_energyConstantParameters.push_back(4.22584e-05);
    m_energyConstantParameters.push_back(-7.54657e-09);
    m_energyConstantParameters.push_back(0.0784297);
    m_energyConstantParameters.push_back(-5.69439e-05);
    m_energyConstantParameters.push_back(-4.95924e-08);
    m_energyConstantParameters.push_back(0.127212);
    m_energyConstantParameters.push_back(4.56414e-05);
    m_energyConstantParameters.push_back(1.41142e-08);

    m_sdhcalThresholds.push_back(1);
    m_sdhcalThresholds.push_back(2);
    m_sdhcalThresholds.push_back(3);
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode SdhcalQuadraticEnergyFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
    unsigned int NHadronicHit  = 0;
    unsigned int NHadronicHit1 = 0;
    unsigned int NHadronicHit2 = 0;
    unsigned int NHadronicHit3 = 0;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHitList);

    float emEnergy = 0.f;
    float otherEnergy = 0.f;

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit = *iter;

      // Ecal case. Get the calibrated hit energy
      if(pandora::ECAL == pCaloHit->GetHitType())
      {
        emEnergy += pCaloHit->GetElectromagneticEnergy();
        continue;
      }
      // SDHCAL case. Do thresholds counting
      else if(pandora::HCAL == pCaloHit->GetHitType())
      {
        if(fabs(m_sdhcalThresholds.at(0) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
          NHadronicHit1++;
        else if(fabs(m_sdhcalThresholds.at(1) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
          NHadronicHit2++;
        else if(fabs(m_sdhcalThresholds.at(2) - pCaloHit->GetInputEnergy()) < std::numeric_limits<float>::epsilon())
          NHadronicHit3++;
        else
        {
          otherEnergy += pCaloHit->GetInputEnergy();
          continue;
        }

        NHadronicHit++;
      }
      // Other hit types ... should never happen
      else
      {
        otherEnergy += pCaloHit->GetInputEnergy();
      }
    }

    // estimate of sdhcal energy
    const float alpha(m_energyConstantParameters.at(0) + m_energyConstantParameters.at(1)*NHadronicHit + m_energyConstantParameters.at(2)*NHadronicHit*NHadronicHit);
    const float beta(m_energyConstantParameters.at(3) + m_energyConstantParameters.at(4)*NHadronicHit + m_energyConstantParameters.at(5)*NHadronicHit*NHadronicHit);
    const float gamma(m_energyConstantParameters.at(6) + m_energyConstantParameters.at(7)*NHadronicHit + m_energyConstantParameters.at(8)*NHadronicHit*NHadronicHit);
    const float hadEnergy(NHadronicHit1*alpha + NHadronicHit2*beta + NHadronicHit3*gamma);

    correctedEnergy = emEnergy + hadEnergy + otherEnergy;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode SdhcalQuadraticEnergyFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    pandora::FloatVector energyConstantParameters;
    pandora::StatusCode statusCode = pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "EnergyConstantParameters", energyConstantParameters);

    if(statusCode == pandora::STATUS_CODE_SUCCESS)
    {
      m_energyConstantParameters = energyConstantParameters;
    }
    else if(statusCode != pandora::STATUS_CODE_NOT_FOUND)
    {
      return statusCode;
    }

    if(9 != m_energyConstantParameters.size())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    pandora::FloatVector sdhcalThresholds;
    statusCode = pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "SdhcalThresholds", sdhcalThresholds);

    if(statusCode == pandora::STATUS_CODE_SUCCESS)
    {
      m_sdhcalThresholds = sdhcalThresholds;
    }
    else if(statusCode != pandora::STATUS_CODE_NOT_FOUND)
    {
      return statusCode;
    }

    if(3 != m_sdhcalThresholds.size())
      return pandora::STATUS_CODE_INVALID_PARAMETER;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  BarrelGapEnergyFunction::BarrelGapEnergyFunction() :
        m_ecalDistanceToGap(5.f),
        m_hcalDistanceToGap(10.f),
        m_ecalInnerGapApproachFactor(0.f),
        m_ecalOuterGapApproachFactor(0.f),
        m_hcalInnerGapApproachFactor(0.f),
        m_hcalOuterGapApproachFactor(0.f)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode BarrelGapEnergyFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
    std::cout << "BarrelGapEnergyFunction: input E = " << correctedEnergy << " GeV" << std::endl;

    if(m_ecalZGapPositions.empty() && m_hcalZGapPositions.empty())
      return pandora::STATUS_CODE_SUCCESS;

    if(pCluster->GetNCaloHits() == 0)
      return pandora::STATUS_CODE_SUCCESS;

    float ecalInnerGapEnergy(0), ecalOuterGapEnergy(0), hcalInnerGapEnergy(0), hcalOuterGapEnergy(0);

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHitList);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);
      const Approach &approach(this->GetApproach(pCaloHit));

      if(approach == FAR_FROM_GAP)
        continue;

      if(pCaloHit->GetHitType() == pandora::ECAL)
      {
        if(approach == INNER_GAP_APPROACH)
          ecalInnerGapEnergy += pCaloHit->GetElectromagneticEnergy();

        if(approach == OUTER_GAP_APPROACH)
          ecalOuterGapEnergy += pCaloHit->GetElectromagneticEnergy();
      }
      else if(pCaloHit->GetHitType() == pandora::HCAL)
      {
        if(approach == INNER_GAP_APPROACH)
          hcalInnerGapEnergy += pCaloHit->GetHadronicEnergy();

        if(approach == OUTER_GAP_APPROACH)
          hcalOuterGapEnergy += pCaloHit->GetHadronicEnergy();
      }
    }

    correctedEnergy +=
        ecalInnerGapEnergy * m_ecalInnerGapApproachFactor +
        ecalOuterGapEnergy * m_ecalOuterGapApproachFactor +
        hcalInnerGapEnergy * m_hcalInnerGapApproachFactor +
        hcalOuterGapEnergy * m_hcalOuterGapApproachFactor;

    std::cout << "BarrelGapEnergyFunction: output E = " << correctedEnergy << " GeV" << std::endl;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode BarrelGapEnergyFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "EcalZGapPositions", m_ecalZGapPositions));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadVectorOfValues(xmlHandle,
        "HcalZGapPositions", m_hcalZGapPositions));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalDistanceToGap", m_ecalDistanceToGap));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalDistanceToGap", m_hcalDistanceToGap));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalInnerGapApproachFactor", m_ecalInnerGapApproachFactor));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EcalOuterGapApproachFactor", m_ecalOuterGapApproachFactor));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalInnerGapApproachFactor", m_hcalInnerGapApproachFactor));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "HcalOuterGapApproachFactor", m_hcalOuterGapApproachFactor));

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  BarrelGapEnergyFunction::Approach BarrelGapEnergyFunction::GetApproach(const pandora::CaloHit *const pCaloHit) const
  {
    if(pCaloHit->GetHitRegion() != pandora::BARREL)
      return FAR_FROM_GAP;

    if(pCaloHit->GetHitType() != pandora::ECAL && pCaloHit->GetHitType() != pandora::HCAL)
      return FAR_FROM_GAP;

    const pandora::FloatVector zGapPositions(pCaloHit->GetHitType() == pandora::ECAL ? m_ecalZGapPositions : m_hcalZGapPositions);
    const float distanceToGap(pCaloHit->GetHitType() == pandora::ECAL ? m_ecalDistanceToGap : m_hcalDistanceToGap);
    const float hitZ(pCaloHit->GetPositionVector().GetZ());

    int approach(FAR_FROM_GAP);

    for(pandora::FloatVector::const_iterator iter = zGapPositions.begin(), endIter = zGapPositions.end() ;
        endIter != iter ; ++iter)
    {
      const float gapZPosition(*iter);

      if( (hitZ < gapZPosition) && (hitZ > gapZPosition-distanceToGap) )
        approach = INNER_GAP_APPROACH;

      if( (hitZ > gapZPosition) && (hitZ < gapZPosition+distanceToGap) )
        approach = OUTER_GAP_APPROACH;

      if(approach != FAR_FROM_GAP)
      {
        if(gapZPosition < 0)
          approach *= -1;

        break;
      }
    }

    return static_cast<Approach>(approach);
  }

  //------------------------------------------------------------------------------------------------------------------------------------------
  //------------------------------------------------------------------------------------------------------------------------------------------

  ThetaEnergyFunction::ThetaEnergyFunction() :
        m_barrelEndcapSeparationCosTheta(0.78),
        m_barrelInterceptP0(-0.931485),
        m_barrelInterceptP1(1.01681),
        m_barrelSlopeP0(-0.327193),
        m_barrelSlopeP1(-0.141193),
        m_endcapInterceptP0(-2.46562),
        m_endcapInterceptP1(0.769711),
        m_endcapSlopeP0(1.58449),
        m_endcapSlopeP1(0.259714),
        m_lowEnergyCut(3.f)
  {
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ThetaEnergyFunction::MakeEnergyCorrections(const pandora::Cluster *const pCluster, float &correctedEnergy) const
  {
    std::cout << "ThetaEnergyFunction: input E = " << correctedEnergy << " GeV" << std::endl;

    if(pCluster->GetNCaloHits() == 0)
      return pandora::STATUS_CODE_SUCCESS;

    if(correctedEnergy < m_lowEnergyCut)
      return pandora::STATUS_CODE_SUCCESS;

    unsigned int startingPseudoLayer(std::numeric_limits<unsigned int>::max());
    const pandora::StatusCode statusCode(ParticleIdHelper::GetStartingPseudoLayer(this->GetPandora(), pCluster, ParticleIdHelper::StartingLayerSettings(), startingPseudoLayer));

    // do not apply energy corrections if starting layer not found
    if(pandora::STATUS_CODE_SUCCESS != statusCode)
      return pandora::STATUS_CODE_SUCCESS;

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHitList);
    float startingHadronicEnergySum(0.f);

    for(pandora::CaloHitList::const_iterator iter = clusterCaloHitList.begin(), endIter = clusterCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      const pandora::CaloHit *const pCaloHit(*iter);

      if(pCaloHit->GetPseudoLayer() >= startingPseudoLayer)
        continue;

      startingHadronicEnergySum += pCaloHit->GetHadronicEnergy();
    }

    // evaluate corrected energy fraction of the main shower part
    // used in following computation since calibration of this correction is done
    // with kaon0L particles. This avoid to correct energy of mip like hadrons
    const float startingHadronicEnergyFraction(startingHadronicEnergySum/pCluster->GetHadronicEnergy());
    const float correctedStartingHadronicEnergy(startingHadronicEnergyFraction*correctedEnergy);
    const float mainCorrectedShowerEnergy(correctedEnergy - correctedStartingHadronicEnergy);

    // calculate energy correction wrt theta angle
    const float interceptBarrel(m_barrelInterceptP0 + mainCorrectedShowerEnergy*m_barrelInterceptP1);
    const float slopeBarrel(m_barrelSlopeP0 + mainCorrectedShowerEnergy*m_barrelSlopeP1);
    const float interceptEndcap(m_endcapInterceptP0 + mainCorrectedShowerEnergy*m_endcapInterceptP1);
    const float slopeEndcap(m_endcapSlopeP0 + mainCorrectedShowerEnergy*m_endcapSlopeP1);
    const float eBarrel0(mainCorrectedShowerEnergy - interceptBarrel);
    const float eeSeparation(interceptEndcap+m_barrelEndcapSeparationCosTheta*slopeEndcap);

    try
    {
      const float clusterCosTheta(this->GetCosTheta(pCluster));
      float energy(mainCorrectedShowerEnergy);

      energy += eBarrel0;
//      correctedEnergy += eBarrel0;

      if(fabs(clusterCosTheta) < m_barrelEndcapSeparationCosTheta)
      {
        std::cout << "Contributions : Ecor = E + " << eBarrel0 << " - " << (fabs(clusterCosTheta)*slopeBarrel) << std::endl;
        energy -= (fabs(clusterCosTheta)*slopeBarrel);
//        correctedEnergy -= (fabs(clusterCosTheta)*slopeBarrel);
      }
      else
      {
        std::cout << "Contributions : Ecor = E + " << eBarrel0 << " + " << (mainCorrectedShowerEnergy-eeSeparation) << " - " << ((fabs(clusterCosTheta)-m_barrelEndcapSeparationCosTheta)*slopeEndcap) << std::endl;

        energy += (mainCorrectedShowerEnergy-eeSeparation);
        energy -= ((fabs(clusterCosTheta)-m_barrelEndcapSeparationCosTheta)*slopeEndcap);

//        correctedEnergy += (correctedEnergy-eeSeparation);
//        correctedEnergy -= ((fabs(clusterCosTheta)-m_barrelEndcapSeparationCosTheta)*slopeEndcap);
      }

      correctedEnergy = startingHadronicEnergyFraction + energy;
    }
    catch(const pandora::StatusCodeException &exception)
    {
      std::cerr << "ThetaEnergyFunction::MakeEnergyCorrections: Couldn't evaluate cluster cos theta : " << exception.ToString() << std::endl;
      return pandora::STATUS_CODE_SUCCESS;
    }

    std::cout << "ThetaEnergyFunction: output E = " << correctedEnergy << " GeV" << std::endl;

    return pandora::STATUS_CODE_SUCCESS;
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  float ThetaEnergyFunction::GetCosTheta(const pandora::Cluster *const pCluster) const
  {
    pandora::CartesianVector centroid(0.f, 0.f, 0.f);
    PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, centroid));

    return fabs(centroid.GetCosOpeningAngle(pandora::CartesianVector(0.f, 0.f, 1.f)));
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

  pandora::StatusCode ThetaEnergyFunction::ReadSettings(const pandora::TiXmlHandle xmlHandle)
  {
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "BarrelEndcapSeparationCosTheta", m_barrelEndcapSeparationCosTheta));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "BarrelInterceptP0", m_barrelInterceptP0));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "BarrelInterceptP1", m_barrelInterceptP1));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "BarrelSlopeP0", m_barrelSlopeP0));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "BarrelSlopeP1", m_barrelSlopeP1));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EndcapInterceptP0", m_endcapInterceptP0));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EndcapInterceptP1", m_endcapInterceptP1));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EndcapSlopeP0", m_endcapSlopeP0));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "EndcapSlopeP1", m_endcapSlopeP1));

    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "LowEnergyCut", m_lowEnergyCut));

    return pandora::STATUS_CODE_SUCCESS;
  }

}


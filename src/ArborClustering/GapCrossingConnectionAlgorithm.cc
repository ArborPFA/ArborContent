  /// \file GapCrossingConnectionAlgorithm.cc
/*
 *
 * GapCrossingConnectionAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 23 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborClustering/GapCrossingConnectionAlgorithm.h"
#include "ArborObjects/CaloHit.h"
#include "ArborHelpers/CaloHitHelper.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ReclusterHelper.h"
#include "ArborHelpers/ClusterHelper.h"

#include "Pandora/AlgorithmHeaders.h"
#include "Helpers/ClusterFitHelper.h"

namespace arbor_content
{

pandora::StatusCode GapCrossingConnectionAlgorithm::Run()
{
	// get ecal and hcal cluster list
	const pandora::ClusterList *pECalClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetList(*this, m_ecalClusterListName, pECalClusterList));

	const pandora::ClusterList *pHCalClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetList(*this, m_hcalClusterListName, pHCalClusterList));

	GapCrossingInfoMap ecalGapGrossingInfoMap;
	GapCrossingInfoMap hcalGapGrossingInfoMap;
	pandora::ClusterList mergedClusterList;

	// find clusters for cross gap connection
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindECalCrossGapConnectCaloHits(pECalClusterList, ecalGapGrossingInfoMap));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindHCalCrossGapConnectCaloHits(pHCalClusterList, hcalGapGrossingInfoMap));

	// if no association to perform, return
	if(ecalGapGrossingInfoMap.empty() || hcalGapGrossingInfoMap.empty())
		return pandora::STATUS_CODE_SUCCESS;

	// connect them
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ConnectGrossGapClusters(ecalGapGrossingInfoMap, hcalGapGrossingInfoMap, mergedClusterList));

	// save the connected cluster list
	if(!mergedClusterList.empty())
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::SaveList(*this, m_ecalClusterListName, m_mergedClusterListName, mergedClusterList));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode GapCrossingConnectionAlgorithm::FindECalCrossGapConnectCaloHits(const pandora::ClusterList *const pClusterList, GapCrossingInfoMap &gapCrossingInfoMap) const
{
	const float ecalBarrelOuterRCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::ECAL_BARREL).GetOuterRCoordinate();
	const float ecalEndcapOuterZCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::ECAL_ENDCAP).GetOuterZCoordinate();

	const unsigned int lastECalBarrelPseudoLayer = PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->GetPseudoLayer(pandora::CartesianVector(0.f, ecalBarrelOuterRCoordinate, 0.f));
	const unsigned int lastECalEndcapPseudoLayer = PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->GetPseudoLayer(pandora::CartesianVector(0.f, 0.f, ecalEndcapOuterZCoordinate));

	// find all leaves for each cluster in ecal eligible to cross gap connect
	for(pandora::ClusterList::const_iterator clusterIter = pClusterList->begin(), clusterEndIter = pClusterList->end() ;
			clusterEndIter != clusterIter ; ++clusterIter)
	{
		const pandora::Cluster *const pCluster = *clusterIter;

		// minimum n hit for cross gap connection
		if(pCluster->GetNCaloHits() == 0 || pCluster->GetNCaloHits() < m_minECalClusterSize)
			continue;

		// check for ecal cluster type only
		if(pandora::ECAL != pCluster->GetOuterLayerHitType())
			continue;

		unsigned int outerPseudoLayer = pCluster->GetOuterPseudoLayer();
		pandora::CaloHitList *pLastPseudoLayerCaloHits = NULL;
		pCluster->GetOrderedCaloHitList().GetCaloHitsInPseudoLayer(outerPseudoLayer, pLastPseudoLayerCaloHits);

		if(pLastPseudoLayerCaloHits->empty())
			continue;

		const pandora::CaloHit *pACaloHit = *pLastPseudoLayerCaloHits->begin();

		// get detector region
		if(pACaloHit->GetHitRegion() != pandora::BARREL && pACaloHit->GetHitRegion() != pandora::ENDCAP)
			continue;

		pandora::ClusterFitResult fitResult;

		if(!m_shouldFitECalBranch)
		{
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::ClusterFitHelper::FitFullCluster(pCluster, fitResult));

			if(!fitResult.IsFitSuccessful())
				continue;
		}

		pandora::CaloHitList leafCaloHitList;
		pandora::CaloHitList clusterCaloHits;
		pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHits);

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::ExtractLeafCaloHitList(&clusterCaloHits, leafCaloHitList));

		// loop over cluster leaves and fill gap crossing info
		for(pandora::CaloHitList::const_iterator hitIter = leafCaloHitList.begin(), hitEndIter = leafCaloHitList.end() ;
				hitEndIter != hitIter ; ++hitIter)
		{
			const arbor_content::CaloHit *pCaloHit = dynamic_cast<const arbor_content::CaloHit *>(*hitIter);

			if(NULL == pCaloHit)
				continue;

			if(pandora::BARREL == pCaloHit->GetHitRegion() && lastECalBarrelPseudoLayer - pCaloHit->GetPseudoLayer() > m_maxOuterECalLayer)
				continue;
			else if(pandora::ENDCAP == pCaloHit->GetHitRegion() && lastECalEndcapPseudoLayer - pCaloHit->GetPseudoLayer() > m_maxOuterECalLayer)
				continue;
			else if(pandora::BARREL != pCaloHit->GetHitRegion() && pandora::ENDCAP != pCaloHit->GetHitRegion())
				continue;

			if(m_shouldFitECalBranch)
			{
				pandora::ClusterFitPointList clusterFitPointList;
				pandora::CaloHitList fitCaloHits;

				PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::BuildCaloHitList(pCaloHit, BACKWARD_DIRECTION, fitCaloHits, m_minECalBranchFitLength, std::numeric_limits<unsigned int>::max()));

				for(pandora::CaloHitList::iterator fitHitIter = fitCaloHits.begin(), fitHitEndIter = fitCaloHits.end() ;
						fitHitEndIter != fitHitIter ; ++fitHitIter)
					clusterFitPointList.push_back(pandora::ClusterFitPoint(*fitHitIter));

				if(clusterFitPointList.size() < 2)
					continue;

				pandora::StatusCode statusCode = pandora::ClusterFitHelper::FitPoints(clusterFitPointList, fitResult);

				if(statusCode != pandora::STATUS_CODE_SUCCESS || !fitResult.IsFitSuccessful())
					continue;
			}

			gapCrossingInfoMap[pCaloHit].m_pCluster = pCluster;
			gapCrossingInfoMap[pCaloHit].m_pCaloHit = pCaloHit;
			gapCrossingInfoMap[pCaloHit].m_fitResult = fitResult;
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode GapCrossingConnectionAlgorithm::FindHCalCrossGapConnectCaloHits(const pandora::ClusterList *const pClusterList, GapCrossingInfoMap &gapCrossingInfoMap) const
{
	const float hcalBarrelInnerRCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::HCAL_BARREL).GetInnerRCoordinate();
	const float hcalEndcapInnerZCoordinate = PandoraContentApi::GetGeometry(*this)->GetSubDetector(pandora::HCAL_ENDCAP).GetInnerZCoordinate();

	const unsigned int firstHCalBarrelPseudoLayer = PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->GetPseudoLayer(pandora::CartesianVector(0.f, hcalBarrelInnerRCoordinate, 0.f));
	const unsigned int firstHCalEndcapPseudoLayer = PandoraContentApi::GetPlugins(*this)->GetPseudoLayerPlugin()->GetPseudoLayer(pandora::CartesianVector(0.f, 0.f, hcalEndcapInnerZCoordinate));

	// find all seeds for each cluster in hcal eligible to cross gap connect
	for(pandora::ClusterList::const_iterator clusterIter = pClusterList->begin(), clusterEndIter = pClusterList->end() ;
			clusterEndIter != clusterIter ; ++clusterIter)
	{
		const pandora::Cluster *const pCluster = *clusterIter;

		if(pCluster->GetNCaloHits() == 0 || pCluster->GetNCaloHits() < m_minHCalClusterSize)
			continue;

		if(pandora::HCAL != pCluster->GetInnerLayerHitType())
			continue;

		unsigned int innerPseudoLayer = pCluster->GetInnerPseudoLayer();
		pandora::CaloHitList *pInnerPseudoLayerCaloHits = NULL;
		pCluster->GetOrderedCaloHitList().GetCaloHitsInPseudoLayer(innerPseudoLayer, pInnerPseudoLayerCaloHits);

		if(pInnerPseudoLayerCaloHits->empty())
			continue;

		const pandora::CaloHit *pACaloHit = *pInnerPseudoLayerCaloHits->begin();

		if(pACaloHit->GetHitRegion() != pandora::BARREL && pACaloHit->GetHitRegion() != pandora::ENDCAP)
			continue;

		pandora::CaloHitList seedCaloHitList;
		pandora::CaloHitList clusterCaloHits;
		pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHits);

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::ExtractSeedCaloHitList(&clusterCaloHits, seedCaloHitList));

		for(pandora::CaloHitList::const_iterator hitIter = seedCaloHitList.begin(), hitEndIter = seedCaloHitList.end() ;
				hitEndIter != hitIter ; ++hitIter)
		{
			const arbor_content::CaloHit *pCaloHit = dynamic_cast<const arbor_content::CaloHit *>(*hitIter);

			if(NULL == pCaloHit)
				continue;

			if(pandora::BARREL == pCaloHit->GetHitRegion() && pCaloHit->GetPseudoLayer() - firstHCalBarrelPseudoLayer > m_maxInnerHCalLayer)
				continue;
			else if(pandora::ENDCAP == pCaloHit->GetHitRegion() && pCaloHit->GetPseudoLayer() - firstHCalEndcapPseudoLayer > m_maxInnerHCalLayer)
				continue;
			else if(pandora::BARREL != pCaloHit->GetHitRegion() && pandora::ENDCAP != pCaloHit->GetHitRegion())
				continue;

			pandora::ClusterFitPointList clusterFitPointList;
			pandora::CaloHitList fitCaloHits;

			// get all hits in the tree getting recursively hits in the forward direction
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::BuildCaloHitList(pCaloHit, FORWARD_DIRECTION, fitCaloHits, m_maxHCalClusterFitPseudoLayer, std::numeric_limits<unsigned int>::max()));

			// build cluster fit points
			for(pandora::CaloHitList::iterator fitHitIter = fitCaloHits.begin(), fitHitEndIter = fitCaloHits.end() ;
					fitHitEndIter != fitHitIter ; ++fitHitIter)
				clusterFitPointList.push_back(pandora::ClusterFitPoint(*fitHitIter));

			if(clusterFitPointList.size() < 2)
				continue;

			// fit hcal interest part
			pandora::ClusterFitResult fitResult;
			pandora::StatusCode statusCode = pandora::ClusterFitHelper::FitPoints(clusterFitPointList, fitResult);

			// requires successful fit !
			if(statusCode != pandora::STATUS_CODE_SUCCESS || !fitResult.IsFitSuccessful())
				continue;

			gapCrossingInfoMap[pCaloHit].m_pCluster = pCluster;
			gapCrossingInfoMap[pCaloHit].m_pCaloHit = pCaloHit;
			gapCrossingInfoMap[pCaloHit].m_fitResult = fitResult;
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode GapCrossingConnectionAlgorithm::ConnectGrossGapClusters(const GapCrossingInfoMap &ecalGapCrossingInfoMap, const GapCrossingInfoMap &hcalGapCrossingInfoMap, pandora::ClusterList &connectedClusterList) const
{
	for(GapCrossingInfoMap::const_iterator hcalIter = hcalGapCrossingInfoMap.begin(), hcalEndIter = hcalGapCrossingInfoMap.end() ;
			hcalEndIter != hcalIter ; ++hcalIter)
	{
		float bestFitAngleDifference2(std::numeric_limits<float>::max());
		GapCrossingInfoMap::const_iterator bestCompatibleConnection = ecalGapCrossingInfoMap.end();

		const pandora::Cluster *pHCalCluster = hcalIter->second.m_pCluster;
		const arbor_content::CaloHit *pHCalSeedCaloHit = hcalIter->second.m_pCaloHit;
		const pandora::CartesianVector hcalFitDirection(hcalIter->second.m_fitResult.GetDirection());

		for(GapCrossingInfoMap::const_iterator ecalIter = ecalGapCrossingInfoMap.begin(), ecalEndIter = ecalGapCrossingInfoMap.end() ;
				ecalEndIter != ecalIter ; ++ecalIter)
		{
			if(hcalIter->first->GetHitRegion() != ecalIter->first->GetHitRegion())
				continue;

			const pandora::CartesianVector ecalFitDirection(ecalIter->second.m_fitResult.GetDirection());
			const float fitAngleDifference2 = ecalFitDirection.GetOpeningAngle(hcalIter->first->GetPositionVector() - ecalIter->first->GetPositionVector());

			if(fitAngleDifference2 < bestFitAngleDifference2
			&& fitAngleDifference2 < m_crossGapFitAngleDifferenceCut2)
			{
				bestFitAngleDifference2 = fitAngleDifference2;
				bestCompatibleConnection = ecalIter;
			}
		}

		if(bestCompatibleConnection == ecalGapCrossingInfoMap.end())
			continue;

		const pandora::Cluster *pECalCluster = bestCompatibleConnection->second.m_pCluster;
		const arbor_content::CaloHit *pECalLeafCaloHit = bestCompatibleConnection->second.m_pCaloHit;

		unsigned int nHCalClusterSeeds = 0;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetNCaloHitSeeds(pHCalCluster, nHCalClusterSeeds));

		const pandora::Cluster *pHCalMergeCluster = NULL;

		// associate the tree cluster
		if(1 == nHCalClusterSeeds)
		{
			pHCalMergeCluster = pHCalCluster;
		}
		// split the cluster with a separate tree cluster for association
		else if(1 < nHCalClusterSeeds)
		{
			const pandora::Cluster *pSeparatedTreeCluster = NULL;

			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ReclusterHelper::SplitTreeFromCluster(*this, pHCalSeedCaloHit,
					pHCalCluster, pSeparatedTreeCluster, m_hcalClusterListName));

			pHCalMergeCluster = pSeparatedTreeCluster;
		}

		// problem ??
		if(NULL == pHCalMergeCluster)
			continue;

		const float differenceDistance = (pECalLeafCaloHit->GetPositionVector() - pHCalSeedCaloHit->GetPositionVector()).GetMagnitude();
		const float connectorNormalization = differenceDistance;//(differenceDistance * m_maxEffectiveGapSeparation) / effectiveCaloHitsSeparation;

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::Connect(pECalLeafCaloHit, pHCalSeedCaloHit, FORWARD_DIRECTION, connectorNormalization));
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::MergeAndDeleteClusters(*this, pECalCluster, pHCalMergeCluster, m_ecalClusterListName, m_hcalClusterListName));

		connectedClusterList.insert(pECalCluster);
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode GapCrossingConnectionAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"ECalClusterListName", m_ecalClusterListName));

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"HCalClusterListName", m_hcalClusterListName));

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MergedClusterListName", m_mergedClusterListName));

	m_maxOuterECalLayer = 2;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxOuterECalLayer", m_maxOuterECalLayer));

	m_maxInnerHCalLayer = 2;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxInnerHCalLayer", m_maxInnerHCalLayer));

	m_minECalClusterSize = 3;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MinECalClusterSize", m_minECalClusterSize));

	m_minHCalClusterSize = 3;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MinHCalClusterSize", m_minHCalClusterSize));

    m_shouldFitECalBranch = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"ShouldFitECalBranch", m_shouldFitECalBranch));

    if(m_shouldFitECalBranch)
    {
        m_minECalBranchFitLength = 4;
        PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        		"MinECalBranchFitLength", m_minECalBranchFitLength));
    }

    m_maxHCalClusterFitPseudoLayer = 6;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
    		"MaxHCalClusterFitPseudoLayer", m_maxHCalClusterFitPseudoLayer));

    m_crossGapFitAngleDifferenceCut = M_PI/6.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        	"CrossGapFitAngleDifferenceCut", m_crossGapFitAngleDifferenceCut));

    m_crossGapFitAngleDifferenceCut2 = M_PI/6.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        	"CrossGapFitAngleDifferenceCut2", m_crossGapFitAngleDifferenceCut2));

    m_maxEffectiveGapSeparation = 70.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        	"MaxEffectiveGapSeparation", m_maxEffectiveGapSeparation));

	return pandora::STATUS_CODE_SUCCESS;
}

} 

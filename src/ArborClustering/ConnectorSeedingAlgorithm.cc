/*
 *
 * ConnectorSeedingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 2 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborClustering/ConnectorSeedingAlgorithm.h"
#include "ArborObjects/CaloHit.h"

#include "Pandora/AlgorithmHeaders.h"

namespace arbor_content
{

pandora::StatusCode ConnectorSeedingAlgorithm::Run()
{
	const pandora::CaloHitList *pCaloHitList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pCaloHitList));

	if(pCaloHitList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	pandora::OrderedCaloHitList orderedCaloHitList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, orderedCaloHitList.Add(*pCaloHitList));

	if(0 == m_seedingStrategy)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->Connect(orderedCaloHitList));
	}
	else if(1 == m_seedingStrategy)
	{
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->AlignConnectors(orderedCaloHitList));
	}
	else
	{
		return pandora::STATUS_CODE_INVALID_PARAMETER;
	}



	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::Connect(const pandora::OrderedCaloHitList &orderedCaloHitList) const
{
	for(pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerEndIter = orderedCaloHitList.end() ;
			layerEndIter != layerIter ; ++layerIter)
	{
		for(pandora::CaloHitList::const_iterator iterI = layerIter->second->begin(), endIterI = layerIter->second->end() ;
				endIterI != iterI ; ++iterI)
		{
			const arbor_content::CaloHit *const pCaloHitI = dynamic_cast<const arbor_content::CaloHit *const>(*iterI);

			if(NULL == pCaloHitI)
				continue;

			if(!PandoraContentApi::IsAvailable(*this, pCaloHitI))
				continue;

			const unsigned int pseudoLayerI = pCaloHitI->GetPseudoLayer();
			const pandora::CartesianVector &positionVectorI(pCaloHitI->GetPositionVector());
			const pandora::HitType hitTypeI(pCaloHitI->GetHitType());

			for(unsigned int pl = pseudoLayerI+1 ; pl <= pseudoLayerI + m_maxPseudoLayerConnection ; ++pl)
			{
				pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pl);

				if(orderedCaloHitList.end() == findIter)
					continue;

				for(pandora::CaloHitList::const_iterator iterJ = findIter->second->begin(), endIterJ = findIter->second->end() ;
						endIterJ != iterJ ; ++iterJ)
				{
					const arbor_content::CaloHit *const pCaloHitJ = dynamic_cast<const arbor_content::CaloHit *const>(*iterJ);

					if(NULL == pCaloHitJ)
						continue;

					if(!PandoraContentApi::IsAvailable(*this, pCaloHitJ))
						continue;

					const pandora::CartesianVector &positionVectorJ(pCaloHitJ->GetPositionVector());
					const pandora::HitType hitTypeJ(pCaloHitJ->GetHitType());

					// check types
					if(m_shouldConnectOnlySameHitType && hitTypeI != hitTypeJ)
						continue;

					const float difference = (positionVectorJ - positionVectorI).GetMagnitude();
					const float maxConnectionDistance = GetPandora().GetGeometry()->GetHitTypeGranularity(hitTypeJ) <= pandora::FINE ?
							m_maxConnectionDistanceFine : m_maxConnectionDistanceCoarse;

					// check distance
					if(difference > maxConnectionDistance)
						continue;

					// check if already connected
					if(pCaloHitI->IsConnected(pCaloHitJ, FORWARD_DIRECTION))
						continue;

					// connect !
					PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCaloHitI->Connect(pCaloHitJ, FORWARD_DIRECTION, maxConnectionDistance));
				}
			}
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::AlignConnectors(const pandora::OrderedCaloHitList &orderedCaloHitList) const
{
	ConnectorList connectorToAlignList;

	for(pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerEndIter = orderedCaloHitList.end() ;
			layerEndIter != layerIter ; ++layerIter)
	{
		for(pandora::CaloHitList::const_iterator iter = layerIter->second->begin(), endIter = layerIter->second->end() ;
				endIter != iter ; ++iter)
		{
			const CaloHit *pCaloHit = dynamic_cast<const CaloHit *>(*iter);

			if(NULL == pCaloHit)
				return pandora::STATUS_CODE_FAILURE;

			const ConnectorList &backwardConnectorList(pCaloHit->GetConnectorList(BACKWARD_DIRECTION));

			if(!backwardConnectorList.empty())
			{
				connectorToAlignList.insert(backwardConnectorList.begin(), backwardConnectorList.end());
			}
		}
	}

	for(ConnectorList::const_iterator connectorIter = connectorToAlignList.begin(), connectorEndIter = connectorToAlignList.end() ;
			connectorEndIter != connectorIter ; ++connectorIter)
	{
		const Connector *const pConnector = *connectorIter;
		const pandora::CartesianVector &connectorVector(pConnector->GetVector(FORWARD_DIRECTION));

		float maxConnectionDistance = GetPandora().GetGeometry()->GetHitTypeGranularity(pConnector->GetTo()->GetHitType()) <= pandora::FINE ?
									m_maxConnectionDistanceFine : m_maxConnectionDistanceCoarse;
		float maxConnectionAngle = GetPandora().GetGeometry()->GetHitTypeGranularity(pConnector->GetTo()->GetHitType()) <= pandora::FINE ?
									m_maxConnectionAngleFine : m_maxConnectionAngleCoarse;

		for(unsigned int pl = pConnector->GetTo()->GetPseudoLayer()+1 ; pl <= pConnector->GetTo()->GetPseudoLayer() + m_maxPseudoLayerConnection ; ++pl)
		{
			pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pl);

			if(orderedCaloHitList.end() == findIter)
				continue;

			for(pandora::CaloHitList::const_iterator iter = findIter->second->begin(), endIter = findIter->second->end() ;
					endIter != iter ; ++iter)
			{
				const CaloHit *const pCaloHit = dynamic_cast<const arbor_content::CaloHit *const>(*iter);

				if(NULL == pCaloHit)
					continue;

				// check types
				if(m_shouldConnectOnlySameHitType && pConnector->GetTo()->GetHitType() != pCaloHit->GetHitType())
					continue;

				const pandora::CartesianVector differenceVector(pCaloHit->GetPositionVector() - pConnector->GetTo()->GetPositionVector());

				// cut on distance
				if(differenceVector.GetMagnitude() > maxConnectionDistance)
					continue;

				// cut on angle
				if(maxConnectionAngle > connectorVector.GetOpeningAngle(differenceVector))
					continue;

				// check if already connected
				if(pConnector->GetTo()->IsConnected(pCaloHit, FORWARD_DIRECTION))
					continue;

				PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pConnector->GetTo()->Connect(pCaloHit, FORWARD_DIRECTION, maxConnectionDistance));
			}
		}

		maxConnectionDistance = GetPandora().GetGeometry()->GetHitTypeGranularity(pConnector->GetFrom()->GetHitType()) <= pandora::FINE ?
									m_maxConnectionDistanceFine : m_maxConnectionDistanceCoarse;
		maxConnectionAngle = GetPandora().GetGeometry()->GetHitTypeGranularity(pConnector->GetFrom()->GetHitType()) <= pandora::FINE ?
									m_maxConnectionAngleFine : m_maxConnectionAngleCoarse;

		const unsigned int startPseudoLayer = pConnector->GetFrom()->GetPseudoLayer()-1;
		const unsigned int endPseudoLayer = pConnector->GetTo()->GetPseudoLayer() <= m_maxPseudoLayerConnection ?
				0 : pConnector->GetTo()->GetPseudoLayer() - m_maxPseudoLayerConnection;

		for(unsigned int pl = startPseudoLayer ; pl != endPseudoLayer ; --pl)
		{
			pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pl);

			if(orderedCaloHitList.end() == findIter)
				continue;

			for(pandora::CaloHitList::const_iterator iter = findIter->second->begin(), endIter = findIter->second->end() ;
					endIter != iter ; ++iter)
			{
				const CaloHit *const pCaloHit = dynamic_cast<const CaloHit *const>(*iter);

				if(NULL == pCaloHit)
					continue;

				// check types
				if(m_shouldConnectOnlySameHitType && pConnector->GetFrom()->GetHitType() != pCaloHit->GetHitType())
					continue;

				const pandora::CartesianVector differenceVector(pCaloHit->GetPositionVector() - pConnector->GetFrom()->GetPositionVector());

				// cut on distance
				if(differenceVector.GetMagnitude() > maxConnectionDistance)
					continue;

				// cut on angle
				if(maxConnectionAngle > (connectorVector * -1.f).GetOpeningAngle(differenceVector))
					continue;

				// check if already connected
				if(pConnector->GetFrom()->IsConnected(pCaloHit, FORWARD_DIRECTION))
					continue;

				PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pConnector->GetFrom()->Connect(pCaloHit, BACKWARD_DIRECTION, maxConnectionDistance));
			}
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ConnectorSeedingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_seedingStrategy = 0;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"SeedingStrategy", m_seedingStrategy));

	m_maxConnectionDistanceFine = 25.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxConnectionDistanceFine", m_maxConnectionDistanceFine));

	m_maxConnectionDistanceCoarse = 45.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxConnectionDistanceCoarse", m_maxConnectionDistanceCoarse));

	m_maxPseudoLayerConnection = 3;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxPseudoLayerConnection", m_maxPseudoLayerConnection));

	m_shouldConnectOnlySameHitType = false;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"ShouldConnectOnlySameHitType", m_shouldConnectOnlySameHitType));

	if(1 == m_seedingStrategy)
	{
		m_maxConnectionAngleFine = M_PI/4.f;
		PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
				"MaxConnectionAngleFine", m_maxConnectionAngleFine));

		m_maxConnectionAngleCoarse = M_PI/4.f;
		PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
				"MaxConnectionAngleCoarse", m_maxConnectionAngleCoarse));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

} 


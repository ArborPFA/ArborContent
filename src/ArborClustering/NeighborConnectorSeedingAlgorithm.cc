/*
 *
 * NeighborConnectorSeedingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : mar. avr. 7 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborClustering/NeighborConnectorSeedingAlgorithm.h"
#include "ArborObjects/CaloHit.h"

#include "Pandora/AlgorithmHeaders.h"

namespace arbor_content
{

pandora::StatusCode NeighborConnectorSeedingAlgorithm::Run()
{
	const pandora::CaloHitList *pCaloHitList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pCaloHitList));

	if(pCaloHitList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	pandora::OrderedCaloHitList orderedCaloHitList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, orderedCaloHitList.Add(*pCaloHitList));

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->Connect(orderedCaloHitList));

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode NeighborConnectorSeedingAlgorithm::Connect(const pandora::OrderedCaloHitList &orderedCaloHitList)
{
	for(pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerEndIter = orderedCaloHitList.end() ;
			layerEndIter != layerIter ; ++layerIter)
	{
		for(pandora::CaloHitList::const_iterator iterI = layerIter->second->begin(), endIterI = layerIter->second->end() ;
				endIterI != iterI ; ++iterI)
		{
			const arbor_content::CaloHit *const pCaloHitI = dynamic_cast<const arbor_content::CaloHit *const>(*iterI);

			if(NULL == pCaloHitI)
				continue;

			if(!PandoraContentApi::IsAvailable(*this, pCaloHitI))
				continue;

			const unsigned int pseudoLayerI = pCaloHitI->GetPseudoLayer();
			const pandora::CartesianVector &positionVectorI(pCaloHitI->GetPositionVector());
			const pandora::HitType hitTypeI(pCaloHitI->GetHitType());

			for(unsigned int pl = pseudoLayerI+1 ; pl <= pseudoLayerI + m_maxPseudoLayerConnection ; ++pl)
			{
				pandora::OrderedCaloHitList::const_iterator findIter = orderedCaloHitList.find(pl);

				if(orderedCaloHitList.end() == findIter)
					continue;

				for(pandora::CaloHitList::const_iterator iterJ = findIter->second->begin(), endIterJ = findIter->second->end() ;
						endIterJ != iterJ ; ++iterJ)
				{
					const arbor_content::CaloHit *const pCaloHitJ = dynamic_cast<const arbor_content::CaloHit *const>(*iterJ);

					if(NULL == pCaloHitJ)
						continue;

					if(!PandoraContentApi::IsAvailable(*this, pCaloHitJ))
						continue;

					const pandora::CartesianVector &positionVectorJ(pCaloHitJ->GetPositionVector());
					const pandora::HitType hitTypeJ(pCaloHitJ->GetHitType());

					// check types
					if(m_shouldConnectOnlySameHitType && hitTypeI != hitTypeJ)
						continue;

					const float difference = (positionVectorJ - positionVectorI).GetMagnitude();
					const float maxConnectionDistance = GetPandora().GetGeometry()->GetHitTypeGranularity(hitTypeJ) <= pandora::FINE ?
							m_maxConnectionDistanceFine : m_maxConnectionDistanceCoarse;

					// check distance
					if(difference > maxConnectionDistance)
						continue;

					// check if already connected
					if(pCaloHitI->IsConnected(pCaloHitJ, FORWARD_DIRECTION))
						continue;

					// connect !
					PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCaloHitI->Connect(pCaloHitJ, FORWARD_DIRECTION, maxConnectionDistance));
				}
			}
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode NeighborConnectorSeedingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_maxConnectionDistanceFine = 25.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxConnectionDistanceFine", m_maxConnectionDistanceFine));

	m_maxConnectionDistanceCoarse = 45.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxConnectionDistanceCoarse", m_maxConnectionDistanceCoarse));

	m_maxPseudoLayerConnection = 3;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxPseudoLayerConnection", m_maxPseudoLayerConnection));

	m_shouldConnectOnlySameHitType = false;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"ShouldConnectOnlySameHitType", m_shouldConnectOnlySameHitType));

	return pandora::STATUS_CODE_SUCCESS;
}


} 


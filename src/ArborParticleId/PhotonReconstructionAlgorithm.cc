  /// \file PhotonReconstructionAlgorithm.cc
/*
 *
 * PhotonReconstructionAlgorithm.cc source template automatically generated by a class generator
 * Creation date : lun. juin 6 2016
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Eté Rémi
 * @copyright CNRS , IPNL
 */


#include "ArborParticleId/PhotonReconstructionAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"
#include "Pandora/PandoraInternal.h"

#include "ArborObjects/CaloHit.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ClusterHelper.h"

namespace arbor_content
{

ShowerBin::ShowerBin() :
		m_energy(0.f),
		m_isAvailable(true),
		m_isUpToDate(true)
{
	/* nop */
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ShowerBin::Add(const pandora::CaloHit *const pCaloHit)
{
	m_caloHitList.insert(pCaloHit);
	m_isUpToDate = false;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ShowerBin::Add(const pandora::CaloHitList &caloHitList)
{
	m_caloHitList.insert(caloHitList.begin(), caloHitList.end());
	m_isUpToDate = false;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ShowerBin::Assign(const pandora::CaloHitList &caloHitList)
{
	m_caloHitList.clear();
	m_caloHitList.insert(caloHitList.begin(), caloHitList.end());
	m_isUpToDate = false;
}

//------------------------------------------------------------------------------------------------------------------------------------------

const pandora::CaloHitList &ShowerBin::GetCaloHitList() const
{
	return m_caloHitList;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float ShowerBin::GetEnergy() const
{
	const_cast<ShowerBin*>(this)->CalculateProperties();
	return m_energy;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool ShowerBin::IsAvailable() const
{
	return m_isAvailable;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ShowerBin::SetAvailability(bool availability)
{
	m_isAvailable = availability;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void ShowerBin::CalculateProperties()
{
	if(m_isUpToDate)
		return;

	m_energy = 0.f;

	for(pandora::CaloHitList::const_iterator iter = m_caloHitList.begin(), endIter = m_caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		const float energy(pCaloHit->GetHitType() == pandora::ECAL ? pCaloHit->GetElectromagneticEnergy() : pCaloHit->GetHadronicEnergy());
		m_energy += energy;
	}

	m_isUpToDate = true;
}

//------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------

Shower2DHistogram::Shower2DHistogram(const unsigned int nBinsX, const float xLow, const float xHigh, const unsigned int nBinsY, const float yLow,
    const float yHigh):
	m_nBinsX(nBinsX),
	m_xLow(xLow),
	m_xHigh(xHigh),
	m_nBinsY(nBinsY),
	m_yLow(yLow),
	m_yHigh(yHigh)
{
    if ((0 >= nBinsX) || (xHigh - xLow < std::numeric_limits<float>::epsilon()))
        throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    m_xBinWidth = (xHigh - xLow) / static_cast<float>(nBinsX);

    if ((0 >= nBinsY) || (yHigh - yLow < std::numeric_limits<float>::epsilon()))
        throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    m_yBinWidth = (yHigh - yLow) / static_cast<float>(nBinsY);
}

//------------------------------------------------------------------------------------------------------------------------------------------

Shower2DHistogram::Shower2DHistogram(const Shower2DHistogram &rhs) :
	m_xyHistogramMap(rhs.m_xyHistogramMap),
	m_nBinsX(rhs.m_nBinsX),
	m_xLow(rhs.m_xLow),
	m_xHigh(rhs.m_xHigh),
	m_xBinWidth(rhs.m_xBinWidth),
	m_nBinsY(rhs.m_nBinsY),
	m_yLow(rhs.m_yLow),
	m_yHigh(rhs.m_yHigh),
	m_yBinWidth(rhs.m_yBinWidth)
{
	/* nop */
}

//------------------------------------------------------------------------------------------------------------------------------------------

int Shower2DHistogram::GetNBinsX() const
{
	return m_nBinsX;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetXLow() const
{
	return m_xLow;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetXHigh() const
{
	return m_xHigh;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetXBinWidth() const
{
	return m_xBinWidth;
}

//------------------------------------------------------------------------------------------------------------------------------------------

int Shower2DHistogram::GetBinX(float xValue)
{
	if(xValue < m_xLow || xValue > m_xHigh)
		return -1;

	return static_cast<int>(( (xValue - m_xLow) / (m_xHigh - m_xLow) ) * static_cast<float>(m_nBinsX));
}

//------------------------------------------------------------------------------------------------------------------------------------------

int Shower2DHistogram::GetNBinsY() const
{
	return m_nBinsY;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetYLow() const
{
	return m_yLow;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetYHigh() const
{
	return m_yHigh;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetYBinWidth() const
{
	return m_yBinWidth;
}

//------------------------------------------------------------------------------------------------------------------------------------------

int Shower2DHistogram::GetBinY(float yValue)
{
	if(yValue < m_yLow || yValue > m_yHigh)
		return -1;

	return static_cast<int>(( (yValue - m_yLow) / (m_yHigh - m_yLow) ) * static_cast<float>(m_nBinsY));
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::CaloHitList Shower2DHistogram::GetBinCaloHitList(const int binX, const int binY) const
{
	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return pandora::CaloHitList();

    ShowerBinMap::const_iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return pandora::CaloHitList();

    return iterXY->second.GetCaloHitList();
}

//------------------------------------------------------------------------------------------------------------------------------------------

unsigned int Shower2DHistogram::GetBinNCaloHits(const int binX, const int binY) const
{
	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return 0;

    ShowerBinMap::const_iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return 0;

    return iterXY->second.GetCaloHitList().size();
}

//------------------------------------------------------------------------------------------------------------------------------------------

float Shower2DHistogram::GetBinEnergy(const int binX, const int binY) const
{
	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return 0;

    ShowerBinMap::const_iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return 0;

    return iterXY->second.GetEnergy();
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::GetMaximumNCaloHits(unsigned int &maximumValue, int &maximumBinX, int &maximumBinY) const
{
    maximumValue = 0;
    maximumBinX = -1; maximumBinY = -1;

    for (int xBin = 0, xBinEnd = m_nBinsX - 1 ; xBin <= xBinEnd; ++xBin)
    {
    	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(xBin);

        if (m_xyHistogramMap.end() == iterX)
            continue;

        for (int yBin = 0, yBinEnd = m_nBinsY - 1 ; yBin <= yBinEnd; ++yBin)
        {
        	ShowerBinMap::const_iterator iterY = iterX->second.find(yBin);

            if (iterX->second.end() == iterY)
                continue;

            const unsigned int nCaloHits(iterY->second.GetCaloHitList().size());

            if (nCaloHits > maximumValue)
            {
                maximumValue = nCaloHits;
                maximumBinX = iterX->first;
                maximumBinY = iterY->first;
            }
        }
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::GetMaximumEnergy(float &maximumValue, int &maximumBinX, int &maximumBinY) const
{
    maximumValue = 0.f;
    maximumBinX = -1; maximumBinY = -1;

    for (int xBin = 0, xBinEnd = m_nBinsX - 1 ; xBin <= xBinEnd; ++xBin)
    {
    	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(xBin);

        if (m_xyHistogramMap.end() == iterX)
            continue;

        for (int yBin = 0, yBinEnd = m_nBinsY - 1 ; yBin <= yBinEnd; ++yBin)
        {
        	ShowerBinMap::const_iterator iterY = iterX->second.find(yBin);

            if (iterX->second.end() == iterY)
                continue;

            const float energy(iterY->second.GetEnergy());

            if (energy > maximumValue)
            {
                maximumValue = energy;
                maximumBinX = iterX->first;
                maximumBinY = iterY->first;
            }
        }
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::SetBinContent(const int binX, const int binY, const pandora::CaloHitList &caloHitList)
{
    if ((binX < -1) || (binX > m_nBinsX) || (binY < -1) || (binY > m_nBinsY))
        throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

    m_xyHistogramMap[binX][binY].Assign(caloHitList);
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::Fill(const float valueX, const float valueY, const pandora::CaloHitList &caloHitList)
{
    const int binX(std::max(-1, std::min(m_nBinsX, static_cast<int>((valueX - m_xLow) / m_xBinWidth)) ));
    const int binY(std::max(-1, std::min(m_nBinsY, static_cast<int>((valueY - m_yLow) / m_yBinWidth)) ));

    ShowerBinMap &yHistogramMap(m_xyHistogramMap[binX]);
    ShowerBinMap::iterator iter = yHistogramMap.find(binY);

    if (yHistogramMap.end() != iter)
    {
        iter->second.Add(caloHitList);
    }
    else
    {
    	std::pair<ShowerBinMap::iterator, bool> inserted(yHistogramMap.insert(ShowerBinMap::value_type(binY, ShowerBin())));

        if (!inserted.second)
            throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);

        inserted.first->second.Add(caloHitList);
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------

void Shower2DHistogram::Fill(const float valueX, const float valueY, const pandora::CaloHit *const pCaloHit)
{
    const int binX(std::max(-1, std::min(m_nBinsX, static_cast<int>((valueX - m_xLow) / m_xBinWidth)) ));
    const int binY(std::max(-1, std::min(m_nBinsY, static_cast<int>((valueY - m_yLow) / m_yBinWidth)) ));

    ShowerBinMap &yHistogramMap(m_xyHistogramMap[binX]);
    ShowerBinMap::iterator iter = yHistogramMap.find(binY);

    if (yHistogramMap.end() != iter)
    {
        iter->second.Add(pCaloHit);
    }
    else
    {
    	std::pair<ShowerBinMap::iterator, bool> inserted(yHistogramMap.insert(ShowerBinMap::value_type(binY, ShowerBin())));

        if (!inserted.second)
            throw pandora::StatusCodeException(pandora::STATUS_CODE_FAILURE);

        inserted.first->second.Add(pCaloHit);
    }
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool Shower2DHistogram::GetBinAvailability(const int binX, const int binY) const
{
	TwoDShowerBinMap::const_iterator iterX = m_xyHistogramMap.find(binX);

    if (m_xyHistogramMap.end() == iterX)
        return true;

    ShowerBinMap::const_iterator iterXY = iterX->second.find(binY);

    if (iterX->second.end() == iterXY)
        return true;

    return iterXY->second.IsAvailable();
}

//------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------

ShowerPeak::ShowerPeak(const pandora::CaloHitList &caloHitList, const ShowerPeak::Bin2DList &binList, const ShowerPeak::Bin2D &maxBin) :
		m_caloHitList(caloHitList),
		m_binList(binList),
		m_maxBin(maxBin)
{
	if(caloHitList.empty())
		throw pandora::StatusCodeException(pandora::STATUS_CODE_INVALID_PARAMETER);

	for(pandora::CaloHitList::const_iterator iter = caloHitList.begin(), endIter = caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		const float energy(pCaloHit->GetHitType() == pandora::ECAL ? pCaloHit->GetElectromagneticEnergy() : pCaloHit->GetHadronicEnergy());
		m_energy += energy;
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------

const pandora::CaloHitList &ShowerPeak::GetCaloHitList() const
{
	return m_caloHitList;
}

//------------------------------------------------------------------------------------------------------------------------------------------

float ShowerPeak::GetEnergy() const
{
	return m_energy;
}

//------------------------------------------------------------------------------------------------------------------------------------------

const ShowerPeak::Bin2DList &ShowerPeak::GetBinList() const
{
	return m_binList;
}

//------------------------------------------------------------------------------------------------------------------------------------------

const ShowerPeak::Bin2D &ShowerPeak::GetMaxBin() const
{
	return m_maxBin;
}

//------------------------------------------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::Run()
{
	const pandora::CaloHitList *pCaloHitList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pCaloHitList));

	if(pCaloHitList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	// Extract ecal calo hits
	pandora::CaloHitList allEcalCaloHitList;
	pandora::CaloHitList photonEcalCaloHitList;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetECalCaloHitList(pCaloHitList, allEcalCaloHitList, photonEcalCaloHitList));

	Shower2DHistogram thetaPhiProjection(m_projectionNThetaBins, -1.f*M_PI, M_PI, m_projectionNPhiBins, -1.f*M_PI, M_PI);
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FillProjectionHistogram(photonEcalCaloHitList, thetaPhiProjection));

	pandora::ClusterVector photonCandidateClusterVector;
	ShowerPeakList showerPeakList;

	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: FindShowerPeakCandidates" << std::endl );
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindShowerPeakCandidates(thetaPhiProjection, photonCandidateClusterVector, showerPeakList));

	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: RemoveTrackSeededClusters" << std::endl );
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveTrackSeededClusters(photonCandidateClusterVector));

	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: RemoveNearbyTrackCaloHits" << std::endl );
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveNearbyTrackCaloHits(photonCandidateClusterVector))

	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: MergeNearbyCaloHits" << std::endl );
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->MergeNearbyCaloHits(photonCandidateClusterVector, allEcalCaloHitList));

	// should be the last step !
//	ARBOR_LOG( "[PhotonReconstructionAlgorithm]: RemovePhotonsUsingParticleId" << std::endl );
//	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemovePhotonsUsingParticleId(photonCandidateClusterVector));

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::GetECalCaloHitList(const pandora::CaloHitList *const pCaloHitList, pandora::CaloHitList &allEcalCaloHitList, pandora::CaloHitList &photonEcalCaloHitList)
{
	if(pCaloHitList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ;
			endIter != iter ; ++iter)
	{
		if(!PandoraContentApi::IsAvailable(*this, *iter))
			continue;

		if((*iter)->GetHitType() != pandora::ECAL)
			continue;

		allEcalCaloHitList.insert(*iter);

		if((*iter)->GetPseudoLayer() > m_maxCaloHitPseudoLayer)
			continue;

		if(!m_shouldUseIsolatedHits && (*iter)->IsIsolated())
			continue;

		photonEcalCaloHitList.insert(*iter);
	}

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::FindShowerPeakCandidates(const Shower2DHistogram &histogram,
		pandora::ClusterVector &clusterVector, ShowerPeakList &showerPeakList)
{
	Shower2DHistogram projectionHistogram(histogram);

	while(1)
	{
		unsigned int maximumValue(0);
		int maximumBinX(0), maximumBinY(0);

		projectionHistogram.GetMaximumNCaloHits(maximumValue, maximumBinX, maximumBinY);

		if(maximumValue < m_projectionMinPeakSize)
			break;

		std::cout << "Peak size = " << maximumValue << std::endl;

		ShowerPeak::Bin2DList binList;
		ShowerPeak::Bin2D bin(maximumBinX, maximumBinY);
		pandora::CaloHitList showerPeakCaloHitList(projectionHistogram.GetBinCaloHitList(maximumBinX, maximumBinY));

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->BuildPeakAroundBin(projectionHistogram, showerPeakCaloHitList, bin, binList));

		ShowerPeak showerPeak(showerPeakCaloHitList, binList, bin);
		showerPeakList.push_back(showerPeak);

		Shower2DHistogram showerPeakProjection(m_photonPeakNThetaBins, -1.f*M_PI, M_PI, m_photonPeakNPhiBins, -1.f*M_PI, M_PI);
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FillProjectionHistogram(showerPeak.GetCaloHitList(), showerPeakProjection));

		maximumValue = 0;
		maximumBinX = 0;
		maximumBinY = 0;

		showerPeakProjection.GetMaximumNCaloHits(maximumValue, maximumBinX, maximumBinY);

		const float maximumPeakTheta( (maximumBinX / static_cast<float>(m_photonPeakNThetaBins) ) * 2*M_PI - M_PI + showerPeakProjection.GetXBinWidth()/2.f);
		const float maximumPeakPhi( (maximumBinY / static_cast<float>(m_photonPeakNPhiBins) ) * 2*M_PI - M_PI + showerPeakProjection.GetYBinWidth()/2.f);

		pandora::OrderedCaloHitList orderedCaloHitList;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, orderedCaloHitList.Add(showerPeakCaloHitList));

		const float peakX(std::sin(maximumPeakTheta)*std::cos(maximumPeakPhi));
		const float peakY(std::sin(maximumPeakTheta)*std::sin(maximumPeakPhi));
		const float peakZ(std::cos(maximumPeakTheta));

		pandora::CartesianVector photonPeakDirection(peakX, peakY, peakZ);
		pandora::CaloHitList photonCaloHitList;

		for(pandora::OrderedCaloHitList::const_iterator layerIter = orderedCaloHitList.begin(), layerEndIter = orderedCaloHitList.end() ;
				layerEndIter != layerIter ; ++layerIter)
		{
			float maxSurroundingEnergy(std::numeric_limits<float>::min());
			const pandora::CaloHit *pBestCaloHit = NULL;

			for(pandora::CaloHitList::const_iterator iter = layerIter->second->begin(), endIter = layerIter->second->end() ;
					endIter != iter ; ++iter)
			{
				if(!PandoraContentApi::IsAvailable(*this, *iter))
					continue;

				const arbor_content::CaloHit *const pCaloHit(dynamic_cast<const arbor_content::CaloHit *const>(*iter));

				const pandora::CartesianVector position(pCaloHit->GetPositionVector());
				float distanceToPeak(0.f);

				if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetClosestDistanceToLine(pandora::CartesianVector(0.f, 0.f, 0.f),
						photonPeakDirection, position, distanceToPeak))
					continue;

				if(pCaloHit->GetSurroundingEnergy() > maxSurroundingEnergy && distanceToPeak < m_photonPeakBestHitMaxDistance)
				{
					pBestCaloHit = pCaloHit;
					maxSurroundingEnergy = pCaloHit->GetSurroundingEnergy();
				}
			}

			if(NULL == pBestCaloHit)
				continue;

			pandora::CaloHitList intraLayerCaloHitList;
			intraLayerCaloHitList.insert(pBestCaloHit);

			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->PerformPhotonPeakLayerClustering(*layerIter->second, pBestCaloHit, intraLayerCaloHitList));

			photonCaloHitList.insert(intraLayerCaloHitList.begin(), intraLayerCaloHitList.end());
		}

		// remove the hits from the projection histogram
		this->RemoveCaloHitsFromHistogram(photonCaloHitList, projectionHistogram);

		if(photonCaloHitList.size() < m_photonMinNHits)
			continue;

		const pandora::Cluster *pCluster = NULL;
		PandoraContentApi::ClusterParameters clusterParameters;
		clusterParameters.m_caloHitList = photonCaloHitList;

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(*this, clusterParameters, pCluster));

		clusterVector.push_back(pCluster);
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::FillProjectionHistogram(const pandora::CaloHitList &caloHitList, Shower2DHistogram &histogram)
{
	for(pandora::CaloHitList::const_iterator iter = caloHitList.begin(), endIter = caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		const pandora::CartesianVector position(pCaloHit->GetPositionVector());
		float radius(0.f), theta(0.f), phi(0.f);

		position.GetSphericalCoordinates(radius, phi, theta);

		histogram.Fill(theta, phi, pCaloHit);
	}

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::BuildPeakAroundBin(Shower2DHistogram &histogram, pandora::CaloHitList &caloHitList, const ShowerPeak::Bin2D &bin, ShowerPeak::Bin2DList &bin2DList)
{
	const int nBinTheta(histogram.GetNBinsX());
	const int nBinPhi(histogram.GetNBinsY());

	const unsigned int binContent(histogram.GetBinNCaloHits(bin.first, bin.second));

	for(int u=-1 ; u<=1 ; u++)
	{
		for(int v=-1 ; v<=1 ; v++)
		{
			const int thetaBinLookup((bin.first+u)%nBinTheta);
			const int phiBinLookup((bin.second+v)%nBinPhi);
			ShowerPeak::Bin2D lookupBin(thetaBinLookup, phiBinLookup);

			if(this->BinAlreadyAdded(thetaBinLookup, phiBinLookup, bin2DList))
				continue;

			const unsigned int binContentLookup(histogram.GetBinNCaloHits(thetaBinLookup, phiBinLookup));

			if(binContent <= binContentLookup)
				continue;

			if(binContentLookup < m_photonPeakMinSize)
				continue;

			pandora::CaloHitList binCaloHitList(histogram.GetBinCaloHitList(thetaBinLookup, phiBinLookup));
			caloHitList.insert(binCaloHitList.begin(), binCaloHitList.end());

			bin2DList.push_back(lookupBin);

			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->BuildPeakAroundBin(histogram, caloHitList, lookupBin, bin2DList));
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool PhotonReconstructionAlgorithm::BinAlreadyAdded(int thetaBin, int phiBin, const ShowerPeak::Bin2DList &bin2DList)
{
	for(ShowerPeak::Bin2DList::const_iterator iter = bin2DList.begin(), endIter = bin2DList.end() ; endIter != iter ; ++iter)
	{
		if(iter->first == thetaBin && iter->second == phiBin)
			return true;
	}

	return false;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::PerformPhotonPeakLayerClustering(const pandora::CaloHitList &inputCaloHitList, const pandora::CaloHit *const pInputCaloHit, pandora::CaloHitList &usedCaloHitList) const
{
	for(pandora::CaloHitList::const_iterator iter = inputCaloHitList.begin(), endIter = inputCaloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		if(pCaloHit == pInputCaloHit)
			continue;

		if(!PandoraContentApi::IsAvailable(*this, pCaloHit))
			continue;

		if(usedCaloHitList.end() != usedCaloHitList.find(pCaloHit))
			continue;

		const float hitDistance((pCaloHit->GetPositionVector() - pInputCaloHit->GetPositionVector()).GetMagnitude());

		if(hitDistance > m_photonPeakHitMaxDistance)
			continue;

		usedCaloHitList.insert(pCaloHit);

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->PerformPhotonPeakLayerClustering(inputCaloHitList, pCaloHit, usedCaloHitList));
	}

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void PhotonReconstructionAlgorithm::RemoveCaloHitsFromHistogram(const pandora::CaloHitList &caloHitList, Shower2DHistogram &histogram)
{
	for(pandora::CaloHitList::const_iterator iter = caloHitList.begin(), endIter = caloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		const pandora::CartesianVector position(pCaloHit->GetPositionVector());
		float radius(0.f), theta(0.f), phi(0.f);

		position.GetSphericalCoordinates(radius, phi, theta);

		const int thetaBin(histogram.GetBinX(theta));
		const int phiBin(histogram.GetBinY(phi));

		if(thetaBin < 0 || phiBin < 0)
		{
			std::cout << "Warning : GetBinX/Y in histogram : theta bin = " << thetaBin << " , phi bin = " << phiBin << std::endl;
			continue;
		}

		pandora::CaloHitList binCaloHitList(histogram.GetBinCaloHitList(thetaBin, phiBin));

		if(!binCaloHitList.erase(pCaloHit))
		{
			std::cout << "Couldn't remove calo hit from histogram !" << std::endl;
			continue;
		}

		histogram.SetBinContent(thetaBin, phiBin, binCaloHitList);
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::RemoveTrackSeededClusters(pandora::ClusterVector &clusterVector)
{
	// Get the current track list to be used as veto
	const pandora::TrackList *pTrackList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pTrackList));

	pandora::TrackVector trackVector(pTrackList->begin(), pTrackList->end());

	const float bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));

	pandora::ClusterVector clusterRemovalList;

	for(pandora::ClusterVector::const_iterator iter = clusterVector.begin(), endIter = clusterVector.end() ; endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster(*iter);

		pandora::CartesianVector clusterCentroid(0.f, 0.f, 0.f);

		if(pandora::STATUS_CODE_SUCCESS != ClusterHelper::GetCentroid(pCluster, clusterCentroid))
			continue;

		for(pandora::TrackVector::const_iterator trackIter = trackVector.begin(), trackEndIter = trackVector.end() ;
				trackEndIter != trackIter ; ++trackIter)
		{
			const pandora::Track *const pTrack(*trackIter);

			const pandora::Helix helix(pTrack->GetTrackStateAtCalorimeter().GetPosition(),
													pTrack->GetTrackStateAtCalorimeter().GetMomentum(), pTrack->GetCharge(), bField);

			pandora::CartesianVector projectionOnHelix(0.f, 0.f, 0.f);

			if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetProjectionOnHelix(helix, clusterCentroid, projectionOnHelix))
				continue;

			const float distanceToHelix((projectionOnHelix-clusterCentroid).GetMagnitude());

			if(distanceToHelix > m_maxTrackClusterDistance)
				continue;

			clusterRemovalList.push_back(pCluster);
			break;
		}
	}

	std::cout << "Track seeded clusters : " << clusterRemovalList.size() << " will be deleted !" << std::endl;

	for(pandora::ClusterVector::const_iterator iter = clusterRemovalList.begin(), endIter = clusterRemovalList.end() ; endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster(*iter);

		for(pandora::ClusterVector::iterator jter = clusterVector.begin(), endJter = clusterVector.end() ; endJter != jter ; ++jter)
		{
			if(*jter == pCluster)
			{
				clusterVector.erase(jter);
				break;
			}
		}

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Delete(*this, pCluster));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::RemoveNearbyTrackCaloHits(pandora::ClusterVector &clusterVector)
{
	// Get the current track list to be used as veto
	const pandora::TrackList *pTrackList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pTrackList));

	pandora::TrackVector trackVector(pTrackList->begin(), pTrackList->end());

	const float bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));

	pandora::ClusterVector clusterRemovalList;

	for(pandora::ClusterVector::const_iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ; clusterEndIter != clusterIter ; ++clusterIter)
	{
		const pandora::Cluster *const pCluster(*clusterIter);

		pandora::CaloHitList clusterCaloHits;
		pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHits);

		pandora::CaloHitList caloHitListRemoval;

		for(pandora::TrackVector::const_iterator trackIter = trackVector.begin(), trackEndIter = trackVector.end() ;
				trackEndIter != trackIter ; ++trackIter)
		{
			const pandora::Track *const pTrack(*trackIter);

			const pandora::Helix helix(pTrack->GetTrackStateAtCalorimeter().GetPosition(),
									pTrack->GetTrackStateAtCalorimeter().GetMomentum(), pTrack->GetCharge(), bField);

			for(pandora::CaloHitList::const_iterator iter = clusterCaloHits.begin(), endIter = clusterCaloHits.end() ;
					endIter != iter ; ++iter)
			{
				const pandora::CaloHit *const pCaloHit(*iter);

				pandora::CartesianVector projectionOnHelix(0.f, 0.f, 0.f);

				if(pandora::STATUS_CODE_SUCCESS != GeometryHelper::GetProjectionOnHelix(helix, pCaloHit->GetPositionVector(), projectionOnHelix))
						continue;

				const float distanceToHelix((projectionOnHelix-pCaloHit->GetPositionVector()).GetMagnitude());

				if(distanceToHelix > m_photonMaxTrackHitDistance)
					continue;

				caloHitListRemoval.insert(pCaloHit);
			}
		}

		for(pandora::CaloHitList::const_iterator iter = caloHitListRemoval.begin(), endIter = caloHitListRemoval.end() ;
				endIter != iter ; ++iter)
		{
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RemoveFromCluster(*this, pCluster, *iter));
		}

		if(pCluster->GetNCaloHits() < m_photonMinNHits)
		{
			clusterRemovalList.push_back(pCluster);
		}
	}

	std::cout << "Nearby tracks photons : " << clusterRemovalList.size() << " will be deleted !" << std::endl;

	for(pandora::ClusterVector::const_iterator iter = clusterRemovalList.begin(), endIter = clusterRemovalList.end() ; endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster(*iter);

		for(pandora::ClusterVector::iterator jter = clusterVector.begin(), endJter = clusterVector.end() ; endJter != jter ; ++jter)
		{
			if(*jter == pCluster)
			{
				clusterVector.erase(jter);
				break;
			}
		}

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Delete(*this, pCluster));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::MergeNearbyCaloHits(const pandora::ClusterVector &clusterVector, const pandora::CaloHitList &inputCaloHitList)
{
	CaloHitToClusterMap caloHitToClusterMap;

	for(pandora::CaloHitList::const_iterator iter = inputCaloHitList.begin(), endIter = inputCaloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(*iter);

		if(!PandoraContentApi::IsAvailable(*this, pCaloHit))
			continue;

		if(!m_shouldUseIsolatedHits && pCaloHit->IsIsolated())
			continue;

		const pandora::CartesianVector &position(pCaloHit->GetPositionVector());
		const pandora::Cluster *pBestCluster = NULL;
		float bestDistanceToCluster(std::numeric_limits<float>::max());

		for(pandora::ClusterVector::const_iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ; clusterEndIter != clusterIter ; ++clusterIter)
		{
			const pandora::Cluster *const pCluster(*clusterIter);

			float distanceToCluster(std::numeric_limits<float>::max());

			if(pandora::STATUS_CODE_SUCCESS != ClusterHelper::GetClosestDistanceApproach(pCluster, position, distanceToCluster))
				continue;

			if(distanceToCluster < m_photonMaxNearbyHitMergingDistance && distanceToCluster < bestDistanceToCluster)
			{
				bestDistanceToCluster = distanceToCluster;
				pBestCluster = pCluster;
			}
		}

		if(NULL != pBestCluster)
		{
			caloHitToClusterMap[pCaloHit] = pBestCluster;
		}
	}

	std::cout << "map size = " << caloHitToClusterMap.size() << std::endl;

	std::map<const pandora::Cluster *, unsigned int> clusterCoutingMap;

	for(CaloHitToClusterMap::const_iterator iter = caloHitToClusterMap.begin(), endIter = caloHitToClusterMap.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster(iter->second);

		std::map<const pandora::Cluster *, unsigned int>::iterator findIter = clusterCoutingMap.find(pCluster);

		if(findIter == clusterCoutingMap.end())
		{
			clusterCoutingMap[pCluster] = 0;
		}
		else
		{
			findIter->second ++;
		}
	}

	for(std::map<const pandora::Cluster *, unsigned int>::iterator iter = clusterCoutingMap.begin(), endIter = clusterCoutingMap.end() ;
			endIter != iter ; ++iter)
	{
		std::cout << "Cluster with n calo hits = " << iter->first->GetNCaloHits() << " will absorbe " << iter->second << " hits" << std::endl;
	}

	for(CaloHitToClusterMap::const_iterator iter = caloHitToClusterMap.begin(), endIter = caloHitToClusterMap.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::CaloHit *const pCaloHit(iter->first);
		const pandora::Cluster *const pCluster(iter->second);

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddToCluster(*this, pCluster, pCaloHit));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::RemovePhotonsUsingParticleId(pandora::ClusterVector &clusterVector)
{
	pandora::ClusterVector clusterRemovalList;

	const pandora::ParticleId *const pParticleId(PandoraContentApi::GetPlugins(*this)->GetParticleId());

	for(pandora::ClusterVector::const_iterator clusterIter = clusterVector.begin(), clusterEndIter = clusterVector.end() ; clusterEndIter != clusterIter ; ++clusterIter)
	{
		const pandora::Cluster *const pCluster(*clusterIter);

		if(!pParticleId->IsPhoton(pCluster))
			clusterRemovalList.push_back(pCluster);
	}

	std::cout << "Bad photons (pid) : " << clusterRemovalList.size() << " will be deleted !" << std::endl;

	for(pandora::ClusterVector::const_iterator iter = clusterRemovalList.begin(), endIter = clusterRemovalList.end() ; endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster(*iter);

		for(pandora::ClusterVector::iterator jter = clusterVector.begin(), endJter = clusterVector.end() ; endJter != jter ; ++jter)
		{
			if(*jter == pCluster)
			{
				clusterVector.erase(jter);
				break;
			}
		}

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Delete(*this, pCluster));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PhotonReconstructionAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_maxCaloHitPseudoLayer = 15;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxCaloHitPseudoLayer", m_maxCaloHitPseudoLayer));

    m_shouldUseIsolatedHits = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ShouldUseIsolatedHits", m_shouldUseIsolatedHits));

    m_projectionNPhiBins = 200;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ProjectionNPhiBins", m_projectionNPhiBins));

    m_projectionNThetaBins = 200;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ProjectionNThetaBins", m_projectionNThetaBins));

    m_projectionMinPeakSize = 1.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ProjectionMinPeakSize", m_projectionMinPeakSize));

    m_monitoringMode = false;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MonitoringMode", m_monitoringMode));

    if(m_monitoringMode)
    {
        m_projectionDrawOption = "lego";
        PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
            "ProjectionDrawOption", m_projectionDrawOption));
    }

    m_thetaTrackProjectionDistance = 2;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "ThetaTrackProjectionDistance", m_thetaTrackProjectionDistance));

    m_phiTrackProjectionDistance = 2;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhiTrackProjectionDistance", m_phiTrackProjectionDistance));

    m_photonPeakMinSize = 5;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonPeakMinSize", m_photonPeakMinSize));

    m_photonPeakNPhiBins = 400;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonPeakNPhiBins", m_photonPeakNPhiBins));

    m_photonPeakNThetaBins = 400;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonPeakNThetaBins", m_photonPeakNThetaBins));

    m_photonPeakBestHitMaxDistance = 15.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonPeakBestHitMaxDistance", m_photonPeakBestHitMaxDistance));

    m_photonPeakHitMaxDistance = 13.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonPeakHitMaxDistance", m_photonPeakHitMaxDistance));

    m_photonMinNHits = 4;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonMinNHits", m_photonMinNHits));

    m_photonMaxTrackHitDistance = 10.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonMaxTrackHitDistance", m_photonMaxTrackHitDistance));

    m_maxTrackClusterDistance = 20.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "MaxTrackClusterDistance", m_maxTrackClusterDistance));

    m_photonMaxAngleOrigin = 0.523;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonMaxAngleOrigin", m_photonMaxAngleOrigin));

    m_photonMaxNearbyHitMergingDistance = 10.f;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        "PhotonMaxNearbyHitMergingDistance", m_photonMaxNearbyHitMergingDistance));

    return pandora::STATUS_CODE_SUCCESS;
}

}


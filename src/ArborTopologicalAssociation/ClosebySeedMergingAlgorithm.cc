  /// \file ClosebySeedMergingAlgorithm.cc
/*
 *
 * ClosebySeedMergingAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 23 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include "Pandora/AlgorithmHeaders.h"

#include "ArborTopologicalAssociation/ClosebySeedMergingAlgorithm.h"

#include "ArborHelpers/CaloHitHelper.h"
#include "ArborHelpers/ClusterHelper.h"

namespace arbor_content
{

pandora::StatusCode ClosebySeedMergingAlgorithm::Run()
{
	const pandora::ClusterList *pClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	if(pClusterList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	CaloHitSeedToClusterMap caloHitSeedToClusterMap;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindMergeCandidateClusters(pClusterList, caloHitSeedToClusterMap));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->MergeCloseBySeedClusters(caloHitSeedToClusterMap));

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ClosebySeedMergingAlgorithm::FindMergeCandidateClusters(const pandora::ClusterList *const pClusterList, CaloHitSeedToClusterMap &caloHitSeedToClusterMap) const
{
	for(pandora::ClusterList::const_iterator iter = pClusterList->begin(), endIter = pClusterList->end() ;
			endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pCluster = *iter;

		// discriminate track
		if(!pCluster->GetAssociatedTrackList().empty())
			continue;

		pandora::CaloHitList clusterCaloHitList;
		pCluster->GetOrderedCaloHitList().GetCaloHitList(clusterCaloHitList);

		pandora::CaloHitList seedCaloHitList;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::ExtractSeedCaloHitList(&clusterCaloHitList, seedCaloHitList, m_discriminateSeedLeafHits));

		if(seedCaloHitList.empty())
			continue;

		for(pandora::CaloHitList::const_iterator hitIter = seedCaloHitList.begin(), endHitIter = seedCaloHitList.end() ;
				endHitIter != hitIter ; ++hitIter)
		{
			const CaloHit *pSeedCaloHit = dynamic_cast<const CaloHit *>(*hitIter);

			if( ( pandora::ECAL == pSeedCaloHit->GetHitType() && !m_mergeECalSeedClusters )
			|| ( pandora::HCAL == pSeedCaloHit->GetHitType() && !m_mergeHCalSeedClusters ) )
				continue;

			if(!caloHitSeedToClusterMap.insert(std::pair<const CaloHit *, const pandora::Cluster *>(pSeedCaloHit, pCluster)).second)
				return pandora::STATUS_CODE_FAILURE;
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ClosebySeedMergingAlgorithm::MergeCloseBySeedClusters(CaloHitSeedToClusterMap &caloHitSeedToClusterMap) const
{
	for(CaloHitSeedToClusterMap::iterator iterI = caloHitSeedToClusterMap.begin(), endIterI = caloHitSeedToClusterMap.end() ;
			endIterI != iterI ; ++iterI)
	{
		const CaloHit *const pSeedCaloHitI = dynamic_cast<const CaloHit *>(iterI->first);

		if(NULL == iterI->second)
			continue;

		const pandora::Cluster *const pClusterI = iterI->second;

		for(CaloHitSeedToClusterMap::iterator iterJ = caloHitSeedToClusterMap.begin(), endIterJ = caloHitSeedToClusterMap.end() ;
				endIterJ != iterJ ; ++iterJ)
		{
			const CaloHit *const pSeedCaloHitJ = dynamic_cast<const CaloHit *>(iterJ->first);

			if(pSeedCaloHitI == pSeedCaloHitJ)
				continue;

			if(NULL == iterJ->second)
				continue;

			const pandora::Cluster *const pClusterJ = iterJ->second;

			// seeds in the same cluster don't need a merging
			if(pClusterI == pClusterJ)
				continue;

			if(pSeedCaloHitI->GetHitType() != pSeedCaloHitJ->GetHitType())
				continue;

			const unsigned int pseudoLayerI = pSeedCaloHitI->GetPseudoLayer();
			const unsigned int pseudoLayerJ = pSeedCaloHitJ->GetPseudoLayer();

			if(std::max(pseudoLayerI, pseudoLayerJ) - std::min(pseudoLayerI, pseudoLayerJ) > m_maxSeedPseudoLayerDifference)
				continue;

			const float seedDistance = (pSeedCaloHitI->GetPositionVector() - pSeedCaloHitJ->GetPositionVector()).GetMagnitude();
			const float maxSeedDistance = this->GetPandora().GetGeometry()->GetHitTypeGranularity(pSeedCaloHitI->GetHitType()) <= pandora::FINE ?
					m_maxSeedDistanceFine : m_maxSeedDistanceCoarse;

			if(seedDistance > maxSeedDistance)
				continue;

			// replace the cluster that will be deleted by the one that will be enlarge
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ReplaceClusterEntryInSeedMap(pClusterJ, pClusterI, caloHitSeedToClusterMap));

			// merge clusters
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::MergeAndDeleteClusters(*this, pClusterI, pClusterJ));
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ClosebySeedMergingAlgorithm::ReplaceClusterEntryInSeedMap(const pandora::Cluster *const pClusterToReplace, const pandora::Cluster *const pClusterReplacement,
		CaloHitSeedToClusterMap &caloHitSeedToClusterMap) const
{
	if(NULL == pClusterToReplace)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	for(CaloHitSeedToClusterMap::iterator iter = caloHitSeedToClusterMap.begin(), endIter = caloHitSeedToClusterMap.end() ;
			endIter != iter ; ++iter)
	{
		if(iter->second == pClusterToReplace)
			iter->second = pClusterReplacement;
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ClosebySeedMergingAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_discriminateSeedLeafHits = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "DiscriminateSeedLeafHits", m_discriminateSeedLeafHits));

	m_maxSeedPseudoLayerDifference = 1;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxSeedPseudoLayerDifference", m_maxSeedPseudoLayerDifference));

	m_maxSeedDistanceFine = 10.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxSeedDistanceFine", m_maxSeedDistanceFine));

	m_maxSeedDistanceCoarse = 25.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxSeedDistanceCoarse", m_maxSeedDistanceCoarse));

	m_mergeECalSeedClusters = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "MergeECalSeedClusters", m_mergeECalSeedClusters));

	m_mergeHCalSeedClusters = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "MergeHCalSeedClusters", m_mergeHCalSeedClusters));

	return pandora::STATUS_CODE_SUCCESS;
}


} 


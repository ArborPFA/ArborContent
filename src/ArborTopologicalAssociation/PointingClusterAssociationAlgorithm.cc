  /// \file PointingClusterAssociationAlgorithm.cc
/*
 *
 * PointingClusterAssociationAlgorithm.cc source template automatically generated by a class generator
 * Creation date : jeu. avr. 9 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include "Pandora/AlgorithmHeaders.h"

#include "ArborTopologicalAssociation/PointingClusterAssociationAlgorithm.h"

#include "ArborHelpers/SortingHelper.h"
#include "ArborHelpers/GeometryHelper.h"
#include "ArborHelpers/ReclusterHelper.h"
#include "ArborHelpers/ClusterHelper.h"
#include "ArborApi/ArborContentApi.h"

#include <algorithm>

namespace arbor_content
{

pandora::StatusCode PointingClusterAssociationAlgorithm::Run()
{
	// get candidate clusters for association
	pandora::ClusterVector clusterVector;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetEligibleClusters(clusterVector));

	// sort them by inner layer
	std::sort(clusterVector.begin(), clusterVector.end(), SortingHelper::SortClustersByInnerLayer);

	ClusterToClusterMap clusterToClusterMap;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindClustersToMerge(clusterVector, clusterToClusterMap));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::MergeClusters(*this, clusterToClusterMap));

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PointingClusterAssociationAlgorithm::GetEligibleClusters(pandora::ClusterVector &clusterVector) const
{
	const pandora::ClusterList *pClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	if(pClusterList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	for(pandora::ClusterList::const_iterator clusterIter = pClusterList->begin(), clusterEndIter = pClusterList->end() ;
			clusterEndIter != clusterIter ; ++clusterIter)
	{
		const pandora::Cluster *const pCluster = *clusterIter;

		if(!this->CanMergeCluster(pCluster))
			continue;

		if(m_discriminatePhotonPid && pCluster->GetParticleIdFlag() == pandora::PHOTON)
			continue;

		clusterVector.push_back(pCluster);
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool PointingClusterAssociationAlgorithm::CanMergeCluster(const pandora::Cluster *const pCluster) const
{
	if(NULL == pCluster)
		return false;

	if(!PandoraContentApi::IsAvailable(*this, pCluster))
		return false;

	if(pCluster->GetNCaloHits() < m_minNCaloHits || pCluster->GetNCaloHits() > m_maxNCaloHits)
		return false;

	const unsigned int nPseudoLayers(pCluster->GetOrderedCaloHitList().size());

	if(nPseudoLayers < m_minNPseudoLayers || nPseudoLayers >= m_maxNPseudoLayers)
		return false;

	return true;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PointingClusterAssociationAlgorithm::FindClustersToMerge(const pandora::ClusterVector &clusterVector, ClusterToClusterMap &clusterToClusterMap) const
{
	for(pandora::ClusterVector::const_iterator iter = clusterVector.begin(), endIter = clusterVector.end() ;
			endIter != iter ; ++iter)
	{
		const pandora::Cluster *const pDaughterCluster = *iter;

		if(NULL == pDaughterCluster)
			continue;

		if( ! pDaughterCluster->GetAssociatedTrackList().empty() )
			continue;

		const pandora::Cluster *pBestParentCluster = NULL;
		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindBestParentCluster(pDaughterCluster, clusterVector, pBestParentCluster));

		if(NULL == pBestParentCluster)
			continue;

		// if neutral cluster
		if(pBestParentCluster->GetAssociatedTrackList().empty())
		{
			clusterToClusterMap[pDaughterCluster] = pBestParentCluster;
		}
		// charged cluster case
		else
		{
			float oldChi(0.f), newChi(0.f);
			PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetChiClusterMerging(this->GetPandora(), pBestParentCluster, pDaughterCluster, oldChi, newChi));

		    // if we improve on chi2 or if chi2 still valid, associate
		    if(newChi*newChi < oldChi*oldChi || newChi*newChi < m_chi2AssociationCut)
		    	clusterToClusterMap[pDaughterCluster] = pBestParentCluster;
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PointingClusterAssociationAlgorithm::FindBestParentCluster(const pandora::Cluster *const pDaughterCluster, const pandora::ClusterVector &clusterVector,
		const pandora::Cluster *&pBestParentCluster) const
{
	pBestParentCluster = NULL;

	if(NULL == pDaughterCluster)
		return pandora::STATUS_CODE_INVALID_PARAMETER;

	pandora::CartesianVector innerPosition(0.f, 0.f, 0.f), backwardDirection(0.f, 0.f, 0.f);
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->GetClusterBackwardDirection(pDaughterCluster, backwardDirection, innerPosition));

	const unsigned int maxBackwardPseudoLayer(pDaughterCluster->GetInnerPseudoLayer() >= m_maxBackwardPseudoLayer ? 0 : pDaughterCluster->GetInnerPseudoLayer()-m_maxBackwardPseudoLayer);
	float bestDistanceToCluster(std::numeric_limits<float>::max());

	for(pandora::ClusterVector::const_reverse_iterator jIter = clusterVector.rbegin(), jEndIter = clusterVector.rend() ;
			jEndIter != jIter ; ++jIter)
	{
		const pandora::Cluster *const pCluster(*jIter);

		if(NULL == pCluster)
			continue;

		if(pCluster == pDaughterCluster)
			continue;

		if(!m_allowNeutralParentMerging && pCluster->GetAssociatedTrackList().empty())
			continue;

		const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());
		unsigned int nHitsInRoi(0);
		unsigned int bestNHitsInRoi(std::numeric_limits<unsigned int>::min());
		pandora::CartesianVector centroidInRoi(0.f, 0.f, 0.f);

		for(pandora::OrderedCaloHitList::const_reverse_iterator layerIter = orderedCaloHitList.rbegin(), layerEndIter = orderedCaloHitList.rend() ;
				layerEndIter != layerIter ; ++layerIter)
		{
			if(layerIter->first <= maxBackwardPseudoLayer)
				break;

			for(pandora::CaloHitList::const_iterator iterI = layerIter->second->begin(), endIterI = layerIter->second->end() ;
					endIterI != iterI ; ++iterI)
			{
				const pandora::CaloHit *const pCaloHit(*iterI);

				const pandora::CartesianVector differenceVector(pCaloHit->GetPositionVector()-innerPosition);
				const float distanceToHit(differenceVector.GetMagnitude());
				const float angleWithCluster(differenceVector.GetOpeningAngle(backwardDirection));
				const pandora::Granularity granularity(this->GetPandora().GetGeometry()->GetHitTypeGranularity(pCaloHit->GetHitType()));

				const float maxBackwardDistance(granularity <= pandora::FINE ? m_maxBackwardDistanceFine : m_maxBackwardDistanceCoarse);

				if(layerIter->first > maxBackwardPseudoLayer && distanceToHit < maxBackwardDistance && angleWithCluster < m_maxBackwardAngle)
				{
					++nHitsInRoi;
					centroidInRoi += pCaloHit->GetPositionVector();
				}
			}
		}

		if(nHitsInRoi > m_minParentClusterBackwardNHits && nHitsInRoi > bestNHitsInRoi)
		{
			centroidInRoi = centroidInRoi * (1.f/nHitsInRoi);
			bestNHitsInRoi = nHitsInRoi;

			const float distanceToCluster((innerPosition - centroidInRoi).GetMagnitude());

			if(distanceToCluster < bestDistanceToCluster)
			{
				bestDistanceToCluster = distanceToCluster;
				pBestParentCluster = pCluster;
			}
		}
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PointingClusterAssociationAlgorithm::GetClusterBackwardDirection(const pandora::Cluster *const pCluster, pandora::CartesianVector &backwardDirection, pandora::CartesianVector &innerPosition) const
{
	pandora::CartesianVector centroid(0.f, 0.f, 0.f);
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ClusterHelper::GetCentroid(pCluster, centroid));

	const pandora::CartesianVector innerCentroid(pCluster->GetCentroid(pCluster->GetInnerPseudoLayer()));

	pandora::ClusterFitResult clusterFitResult;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::ClusterFitHelper::FitStart(pCluster, m_nBackwardLayersFit, clusterFitResult));
	const pandora::CartesianVector clusterDirection(clusterFitResult.GetDirection());

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, GeometryHelper::GetProjectionOnLine(centroid, clusterDirection, innerCentroid, innerPosition));
	backwardDirection = clusterDirection * -1.f;

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode PointingClusterAssociationAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_discriminatePhotonPid = true;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "DiscriminatePhotonPid", m_discriminatePhotonPid));

	m_allowNeutralParentMerging = false;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "AllowNeutralParentMerging", m_allowNeutralParentMerging));

	m_minNCaloHits = 10;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MinNCaloHits", m_minNCaloHits));

	m_maxNCaloHits = std::numeric_limits<unsigned int>::max();
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxNCaloHits", m_maxNCaloHits));

	m_minNPseudoLayers = 4;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MinNPseudoLayers", m_minNPseudoLayers));

	m_maxNPseudoLayers = std::numeric_limits<unsigned int>::max();
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxNPseudoLayers", m_maxNPseudoLayers));

	m_chi2AssociationCut = 1.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "Chi2AssociationCut", m_chi2AssociationCut));

	m_nBackwardLayersFit = 6;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "NBackwardLayersFit", m_nBackwardLayersFit));

	m_maxBackwardAngle = 0.4;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxBackwardAngle", m_maxBackwardAngle));

	m_maxBackwardDistanceFine = 150.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxBackwardDistanceFine", m_maxBackwardDistanceFine));

	m_maxBackwardDistanceCoarse = 500.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxBackwardDistanceCoarse", m_maxBackwardDistanceCoarse));

	m_maxBackwardPseudoLayer = 8;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MaxBackwardPseudoLayer", m_maxBackwardPseudoLayer));

	m_minParentClusterBackwardNHits = 5;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
	     "MinParentClusterBackwardNHits", m_minParentClusterBackwardNHits));


	return pandora::STATUS_CODE_SUCCESS;
}


} 


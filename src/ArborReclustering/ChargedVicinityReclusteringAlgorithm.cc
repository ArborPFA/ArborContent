  /// \file ChargedVicinityReclusteringAlgorithm.cc
/*
 *
 * ChargedVicinityReclusteringAlgorithm.cc source template automatically generated by a class generator
 * Creation date : mar. dï¿½c. 8 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborReclustering/ChargedVicinityReclusteringAlgorithm.h"

#include "Pandora/AlgorithmHeaders.h"

#include "ArborApi/ArborContentApi.h"
#include "ArborHelpers/ReclusterHelper.h"
#include "ArborHelpers/ClusterHelper.h"

namespace arbor_content
{

pandora::StatusCode ChargedVicinityReclusteringAlgorithm::Run()
{
	const pandora::ClusterList *pClusterList = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(*this, pClusterList));

	if(pClusterList->empty())
		return pandora::STATUS_CODE_SUCCESS;

	pandora::ClusterVector clusterVector(pClusterList->begin(), pClusterList->end());
	const unsigned int nClusters(clusterVector.size());

	const float bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));

		for(unsigned int i=0 ; i<nClusters ; ++i)
		{
			const pandora::Cluster *const pCluster = clusterVector[i];

		if(NULL == pCluster)
			continue;

		const pandora::TrackList &trackList(pCluster->GetAssociatedTrackList());

		// need exactly one track
		if(trackList.size() != 1)
			continue;

		const float chi(ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), pCluster, trackList));

		// check for chi2
		if(chi*chi < m_minChi2ToRunReclustering)
			continue;

		if(chi < 0.f && ClusterHelper::IsClusterLeavingDetector(this->GetPandora(), pCluster))
			continue;

		const float clusterEnergyI(pCluster->GetCorrectedHadronicEnergy(this->GetPandora()));

		ARBOR_LOG( "Cluster energy = " << clusterEnergyI << " GeV" << std::endl );
	    ARBOR_LOG( "Track p = " << (*trackList.begin())->GetEnergyAtDca() << " GeV , chi = " << chi << std::endl );

		// prepare clusters and tracks for reclustering
	    pandora::ClusterList reclusterClusterList;
	    reclusterClusterList.insert(pCluster);
	    pandora::TrackList reclusterTrackList(trackList);

	    UIntVector originalClusterIndices(1, i);

		const pandora::Track *const pTrack(*trackList.begin());
		const pandora::Helix helix(pTrack->GetTrackStateAtCalorimeter().GetPosition(),
				pTrack->GetTrackStateAtCalorimeter().GetMomentum(), pTrack->GetCharge(), bField);

		for(unsigned int j=0 ; j<nClusters ; ++j)
		{
			const pandora::Cluster *const pOtherCluster = clusterVector[j];

			if(NULL == pOtherCluster)
				continue;

			if(pOtherCluster == pCluster)
				continue;

			if(pOtherCluster->GetAssociatedTrackList().size() != 1)
				continue;

			const pandora::Track *const pOtherTrack(*pOtherCluster->GetAssociatedTrackList().begin());
			const pandora::CartesianVector &trackProjection(pOtherTrack->GetTrackStateAtCalorimeter().GetPosition());

			const float localChi(ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), pOtherCluster, pOtherCluster->GetAssociatedTrackList()));

			if(localChi*localChi < m_minChi2ToRunReclustering)
				continue;

			if(localChi < 0.f && ClusterHelper::IsClusterLeavingDetector(this->GetPandora(), pOtherCluster))
				continue;

			pandora::CartesianVector distanceToHelix(0.f, 0.f, 0.f);
			helix.GetDistanceToPoint(trackProjection, distanceToHelix);

			ARBOR_LOG( " ==> Other track p = " << pOtherTrack->GetEnergyAtDca() << " GeV , distance = " << distanceToHelix.GetZ() << " mm" << std::endl );

			if(distanceToHelix.GetZ() > m_maxTrackSeparationDistance)
				continue;

			ARBOR_LOG( "Found nearby track p = " << pOtherTrack->GetEnergyAtDca() << " GeV , chi = " << localChi << " , distance = " << distanceToHelix.GetZ() << " mm" << std::endl );

			reclusterClusterList.insert(pOtherCluster);
			reclusterTrackList.insert(pOtherTrack);
			originalClusterIndices.push_back(j);
		}

	    if(1 == reclusterTrackList.size() || 1 == reclusterClusterList.size())
	    	continue;

	    float totalChi(0.f);
	    float worstChi(std::numeric_limits<float>::min());

	    for(pandora::ClusterList::const_iterator jter = reclusterClusterList.begin(), endJter = reclusterClusterList.end() ;
	    		endJter != jter ; ++jter)
	    {
	    	const float localChi(ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), *jter, (*jter)->GetAssociatedTrackList()));

	    	if(localChi*localChi > worstChi*worstChi)
	    		worstChi = localChi;

	    	totalChi += localChi;
	    }

	    ARBOR_LOG( "Total chi = " << totalChi << " , worstChi = " << worstChi << " compared to " << std::sqrt(m_minChi2ToRunReclustering) << std::endl );

	    if(totalChi*totalChi > m_minChi2ToRunReclustering)
	    	continue;

	    // initialize reclustering
	    std::string originalClusterListName;
	    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::InitializeReclustering(*this,
	    		reclusterTrackList, reclusterClusterList, originalClusterListName));

	    float bestChi(chi);
	    std::string bestReclusterClusterListName(originalClusterListName);

	    for(pandora::StringVector::const_iterator clusteringAlgIter = m_clusteringAlgorithmList.begin(), endClusteringAlgIter = m_clusteringAlgorithmList.end() ;
	    		endClusteringAlgIter != clusteringAlgIter ; ++clusteringAlgIter)
	    {
	    	const pandora::ClusterList *pReclusterClusterList = NULL;
	    	std::string reclusterClusterListName;
	    	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::RunReclusteringAlgorithm(*this,
	    			*clusteringAlgIter, pReclusterClusterList, reclusterClusterListName));

	    	if(pReclusterClusterList->empty())
	    		continue;

	    	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this,
	    			m_associationAlgorithmName));

	    	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::PostRunReclusteringAlgorithm(*this, reclusterClusterListName));

			float worstLocalChi(std::numeric_limits<float>::min());

	    	for(pandora::ClusterList::const_iterator reclusterIter = pReclusterClusterList->begin(), reclusterEndIter = pReclusterClusterList->end() ;
	    			reclusterEndIter != reclusterIter ; ++reclusterIter)
	    	{
	    		const pandora::Cluster *const pReclusterCluster = *reclusterIter;
	    		const pandora::TrackList &newTrackList(pReclusterCluster->GetAssociatedTrackList());

	    		if(newTrackList.empty())
	    			continue;

	    		const float newChi(ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), pReclusterCluster, newTrackList));

	    		if(worstLocalChi*worstLocalChi < newChi*newChi)
	    			worstLocalChi = newChi;
	    	}

	    	ARBOR_LOG( "New chi = " << worstLocalChi << std::endl );

	    	if(worstLocalChi*worstLocalChi < bestChi*bestChi)
	    	{
				bestChi = worstLocalChi;
				bestReclusterClusterListName = reclusterClusterListName;

				if(bestChi*bestChi < m_maxChi2ToStopReclustering)
					break;
	    	}
	    }

        // tidy the cluster vector used for reclustering
        if( originalClusterListName != bestReclusterClusterListName )
        {
        	for(UIntVector::const_iterator iter = originalClusterIndices.begin(), endIter = originalClusterIndices.end() ;
        			endIter != iter ; ++iter)
        		clusterVector[*iter] = NULL;
        }

        // Recreate track-cluster associations for chosen recluster candidates
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::TemporarilyReplaceCurrentList<pandora::Cluster>(*this, bestReclusterClusterListName));
        PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this, m_trackClusterAssociationAlgName));

    	// run monitoring algorithm if provided
    	if(!m_monitoringAlgorithmName.empty())
    	{
	    	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunDaughterAlgorithm(*this,
	    			m_monitoringAlgorithmName));
    	}

	    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::EndReclustering(*this, bestReclusterClusterListName));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ChargedVicinityReclusteringAlgorithm::FindNeighborClusters(const pandora::ClusterVector &inputClusterVector, const pandora::Cluster *const pCluster,
		pandora::TrackList &trackList, pandora::ClusterList &clusterList) const
{
	const unsigned int nClusters(inputClusterVector.size());
	const pandora::Track *const pTrack(*pCluster->GetAssociatedTrackList().begin());

	const float bField(PandoraContentApi::GetPlugins(*this)->GetBFieldPlugin()->GetBField(pandora::CartesianVector(0.f, 0.f, 0.f)));
	const pandora::Helix helix(pTrack->GetTrackStateAtCalorimeter().GetPosition(),
			pTrack->GetTrackStateAtCalorimeter().GetMomentum(), pTrack->GetCharge(), bField);

	for(unsigned int i=0 ; i<nClusters ; ++i)
	{
		const pandora::Cluster *const pOtherCluster = inputClusterVector[i];

		if(NULL == pOtherCluster)
			continue;

		if(pOtherCluster == pCluster)
			continue;

		if(pOtherCluster->GetAssociatedTrackList().size() != 1)
			continue;

		const pandora::Track *const pOtherTrack(*pOtherCluster->GetAssociatedTrackList().begin());
		const pandora::CartesianVector &trackProjection(pOtherTrack->GetTrackStateAtCalorimeter().GetPosition());

		const float chi(ReclusterHelper::GetTrackClusterCompatibility(this->GetPandora(), pOtherCluster, pOtherCluster->GetAssociatedTrackList()));

		if(chi*chi < m_minChi2ToRunReclustering)
			continue;

		pandora::CartesianVector distanceToHelix(0.f, 0.f, 0.f);
		helix.GetDistanceToPoint(trackProjection, distanceToHelix);

		ARBOR_LOG( " ==> Other track p = " << pOtherTrack->GetEnergyAtDca() << " GeV , distance = " << distanceToHelix.GetZ() << " mm" << std::endl );

		if(distanceToHelix.GetZ() > m_maxTrackSeparationDistance)
			continue;

		ARBOR_LOG( "Found nearby track p = " << pOtherTrack->GetEnergyAtDca() << " GeV , chi = " << chi << " , distance = " << distanceToHelix.GetZ() << " mm" << std::endl );

		clusterList.insert(pOtherCluster);
		trackList.insert(pOtherTrack);
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode ChargedVicinityReclusteringAlgorithm::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_minChi2ToRunReclustering = 2.5f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "MinChi2ToRunReclustering", m_minChi2ToRunReclustering));

	m_maxChi2ToStopReclustering = 0.5f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "MaxChi2ToStopReclustering", m_maxChi2ToStopReclustering));

	m_maxTrackSeparationDistance = 13.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
		 "MaxTrackSeparationDistance", m_maxTrackSeparationDistance));

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithmList(*this, xmlHandle,
		 "clusteringAlgorithms", m_clusteringAlgorithmList));

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
		 "ClusterAssociation", m_associationAlgorithmName));

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
		 "TrackClusterAssociation", m_trackClusterAssociationAlgName));

	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ProcessAlgorithm(*this, xmlHandle,
		 "Monitoring", m_monitoringAlgorithmName));

	return pandora::STATUS_CODE_SUCCESS;
}

} 


/*
 *
 * CaloHit.cc source template automatically generated by a class generator
 * Creation date : lun. mars 30 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborObjects/CaloHit.h"

namespace arbor_content
{

CaloHit::CaloHit(const PandoraApi::RectangularCaloHit::Parameters &parameters, const ArborApi::CaloHitParameters &arborParameters) :
		pandora::CaloHit(parameters),
		m_cellSize0(parameters.m_cellSizeU.Get()),
		m_cellSize1(parameters.m_cellSizeV.Get()),
		m_cellLengthScale(std::sqrt(m_cellSize0 * m_cellSize0)),
		m_semiDigitalThreshold(arborParameters.m_semiDigitalThreshold.Get()),
		m_caloHitMetaData(this)
{
	m_cellGeometry = pandora::RECTANGULAR;
	ClearTagMap();
}

//------------------------------------------------------------------------------------------------------------------------------------------

CaloHit::CaloHit(const PandoraApi::PointingCaloHit::Parameters &parameters, const ArborApi::CaloHitParameters &arborParameters) :
		pandora::CaloHit(parameters),
		m_cellSize0(parameters.m_cellSizeEta.Get()),
		m_cellSize1(parameters.m_cellSizePhi.Get()),
		m_cellLengthScale(this->CalculateCellLengthScale()),
		m_semiDigitalThreshold(arborParameters.m_semiDigitalThreshold.Get()),
		m_caloHitMetaData(this)
{
	m_cellGeometry = pandora::POINTING;
	ClearTagMap();
}

//------------------------------------------------------------------------------------------------------------------------------------------

CaloHit::CaloHit(const CaloHit *const pCaloHit, float weight) :
		pandora::CaloHit(pCaloHit, weight),
		m_cellSize0(pCaloHit->GetCellSize0()),
		m_cellSize1(pCaloHit->GetCellSize1()),
		m_cellLengthScale(pCaloHit->GetCellLengthScale()),
		m_semiDigitalThreshold(pCaloHit->GetSemiDigitalThreshold()),
		m_caloHitMetaData(this),
		m_hitTagMap(pCaloHit->m_hitTagMap)
{
	m_cellGeometry = pCaloHit->GetCellGeometry();
}

//------------------------------------------------------------------------------------------------------------------------------------------

CaloHit::~CaloHit()
{
	PANDORA_THROW_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveAllConnections());
}

//------------------------------------------------------------------------------------------------------------------------------------------

void CaloHit::GetCellCorners(pandora::CartesianPointList &cartesianPointList) const
{
	if(m_cellGeometry == pandora::RECTANGULAR)
	{
	    const pandora::CartesianVector &position(this->GetPositionVector());

	    pandora::CartesianVector normal(this->GetCellNormalVector());
	    pandora::CartesianVector dirU((pandora::BARREL == this->GetHitRegion()) ?
	    		pandora::CartesianVector(0.f, 0.f, 1.f) : pandora::CartesianVector(0.f, 1.f, 0.f) );
	    pandora::CartesianVector dirV(normal.GetCrossProduct(dirU));

	    dirU *= (this->GetCellSize0() / 2.);
	    dirV *= (this->GetCellSize1() / 2.);
	    normal *= (this->GetCellThickness() / 2.);

	    cartesianPointList.push_back(pandora::CartesianVector(position - dirU - dirV - normal));
	    cartesianPointList.push_back(pandora::CartesianVector(position + dirU - dirV - normal));
	    cartesianPointList.push_back(pandora::CartesianVector(position + dirU + dirV - normal));
	    cartesianPointList.push_back(pandora::CartesianVector(position - dirU + dirV - normal));

	    cartesianPointList.push_back(pandora::CartesianVector(position - dirU - dirV + normal));
	    cartesianPointList.push_back(pandora::CartesianVector(position + dirU - dirV + normal));
	    cartesianPointList.push_back(pandora::CartesianVector(position + dirU + dirV + normal));
	    cartesianPointList.push_back(pandora::CartesianVector(position - dirU + dirV + normal));
	}
	else
	{
	    float radius(0.f), phi(0.f), theta(0.f);
	    this->GetPositionVector().GetSphericalCoordinates(radius, phi, theta);
	    const float centralEta(-1. * std::log(std::tan(theta / 2.)));

	    const float rMin(radius - this->GetCellThickness() / 2.), rMax(radius + this->GetCellThickness() / 2.);
	    const float phiMin(phi - this->GetCellSize1() / 2.), phiMax(phi + this->GetCellSize1() / 2.);
	    const float etaMin(centralEta - this->GetCellSize0() / 2.), etaMax(centralEta + this->GetCellSize0() / 2.);
	    const float thetaMin(2. * std::atan(std::exp(-1. * etaMin))), thetaMax(2. * std::atan(std::exp(-1. * etaMax)));

	    const float sinTheta(std::sin(theta)), cosTheta(std::cos(theta));
	    const float sinThetaMin(std::sin(thetaMin)), cosThetaMin(std::cos(thetaMin)), sinPhiMin(std::sin(phiMin)), cosPhiMin(std::cos(phiMin));
	    const float sinThetaMax(std::sin(thetaMax)), cosThetaMax(std::cos(thetaMax)), sinPhiMax(std::sin(phiMax)), cosPhiMax(std::cos(phiMax));

	    float thetaMinRScale(1.f), thetaMaxRScale(1.f);

	    if (pandora::BARREL == this->GetHitRegion())
	    {
	        if (std::fabs(sinThetaMin) > std::numeric_limits<float>::epsilon())
	            thetaMinRScale = std::fabs(sinTheta / sinThetaMin);

	        if (std::fabs(sinThetaMax) > std::numeric_limits<float>::epsilon())
	            thetaMaxRScale = std::fabs(sinTheta / sinThetaMax);
	    }
	    else
	    {
	        if (std::fabs(cosThetaMin) > std::numeric_limits<float>::epsilon())
	            thetaMinRScale = std::fabs(cosTheta / cosThetaMin);

	        if (std::fabs(cosThetaMax) > std::numeric_limits<float>::epsilon())
	            thetaMaxRScale = std::fabs(cosTheta / cosThetaMax);
	    }

	    const float rMinAtThetaMin(thetaMinRScale * rMin), rMinAtThetaMax(thetaMaxRScale * rMin);
	    const float rMaxAtThetaMin(thetaMinRScale * rMax), rMaxAtThetaMax(thetaMaxRScale * rMax);

	    cartesianPointList.push_back(pandora::CartesianVector(rMinAtThetaMin * sinThetaMin * cosPhiMin, rMinAtThetaMin * sinThetaMin * sinPhiMin, rMinAtThetaMin * cosThetaMin));
	    cartesianPointList.push_back(pandora::CartesianVector(rMinAtThetaMax * sinThetaMax * cosPhiMin, rMinAtThetaMax * sinThetaMax * sinPhiMin, rMinAtThetaMax * cosThetaMax));
	    cartesianPointList.push_back(pandora::CartesianVector(rMinAtThetaMax * sinThetaMax * cosPhiMax, rMinAtThetaMax * sinThetaMax * sinPhiMax, rMinAtThetaMax * cosThetaMax));
	    cartesianPointList.push_back(pandora::CartesianVector(rMinAtThetaMin * sinThetaMin * cosPhiMax, rMinAtThetaMin * sinThetaMin * sinPhiMax, rMinAtThetaMin * cosThetaMin));

	    cartesianPointList.push_back(pandora::CartesianVector(rMaxAtThetaMin * sinThetaMin * cosPhiMin, rMaxAtThetaMin * sinThetaMin * sinPhiMin, rMaxAtThetaMin * cosThetaMin));
	    cartesianPointList.push_back(pandora::CartesianVector(rMaxAtThetaMax * sinThetaMax * cosPhiMin, rMaxAtThetaMax * sinThetaMax * sinPhiMin, rMaxAtThetaMax * cosThetaMax));
	    cartesianPointList.push_back(pandora::CartesianVector(rMaxAtThetaMax * sinThetaMax * cosPhiMax, rMaxAtThetaMax * sinThetaMax * sinPhiMax, rMaxAtThetaMax * cosThetaMax));
	    cartesianPointList.push_back(pandora::CartesianVector(rMaxAtThetaMin * sinThetaMin * cosPhiMax, rMaxAtThetaMin * sinThetaMin * sinPhiMax, rMaxAtThetaMin * cosThetaMin));
	}
}

//------------------------------------------------------------------------------------------------------------------------------------------

float CaloHit::CalculateCellLengthScale() const
{
    float radius(0.f), phi(0.f), theta(0.f);
    this->GetPositionVector().GetSphericalCoordinates(radius, phi, theta);
    const float centralEta(-1. * std::log(std::tan(theta / 2.)));

    const float etaMin(centralEta - this->GetCellSize0() / 2.), etaMax(centralEta + this->GetCellSize0() / 2.);
    const float thetaMin(2. * std::atan(std::exp(-1. * etaMin))), thetaMax(2. * std::atan(std::exp(-1. * etaMax)));

    return std::sqrt(std::fabs(radius * this->GetCellSize1() * radius * (thetaMax - thetaMin)));
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool CaloHit::IsConnected(const arbor_content::CaloHit *const pCaloHit) const
{
	return m_caloHitMetaData.IsConnected(pCaloHit);
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool CaloHit::IsConnected(const arbor_content::CaloHit *const pCaloHit, ConnectorDirection direction) const
{
	return m_caloHitMetaData.IsConnected(pCaloHit, direction);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CaloHit::FindConnector(const arbor_content::CaloHit *const pCaloHit, const Connector *&pConnector) const
{
	return m_caloHitMetaData.FindConnector(pCaloHit, pConnector);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CaloHit::FindConnector(const arbor_content::CaloHit *const pCaloHit, ConnectorDirection direction,
		const Connector *&pConnector) const
{
	return m_caloHitMetaData.FindConnector(pCaloHit, direction, pConnector);
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool CaloHit::HasAnyConnection() const
{
	return m_caloHitMetaData.HasAnyConnection();
}

//------------------------------------------------------------------------------------------------------------------------------------------

const ConnectorList &CaloHit::GetConnectorList() const
{
	return m_caloHitMetaData.GetConnectorList();
}

//------------------------------------------------------------------------------------------------------------------------------------------

const ConnectorList &CaloHit::GetConnectorList(ConnectorDirection direction) const
{
	return m_caloHitMetaData.GetConnectorList(direction);
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool CaloHit::IsSeed() const
{
	return m_caloHitMetaData.IsSeed();
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool CaloHit::IsLeaf() const
{
	return m_caloHitMetaData.IsLeaf();
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CaloHit::Connect(const CaloHit *const pCaloHit, ConnectorDirection direction,
		float referenceLength) const
{
	const Connector *pConnector = NULL;
	return this->Connect(pCaloHit, direction, pConnector, referenceLength);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CaloHit::Connect(const CaloHit *const pCaloHit, ConnectorDirection direction,
			const Connector *&pConnector, float referenceLength) const
{
	pConnector = NULL;

	CaloHit *const pCaloHitFrom = direction == BACKWARD_DIRECTION ? this->Modifiable(pCaloHit) : this->Modifiable(this);
	CaloHit *const pCaloHitTo = direction == BACKWARD_DIRECTION ? this->Modifiable(this) : this->Modifiable(pCaloHit);

	pConnector = new Connector(pCaloHitFrom, pCaloHitTo, referenceLength);

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCaloHitFrom->m_caloHitMetaData.AddConnector(pConnector, FORWARD_DIRECTION));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCaloHitTo->m_caloHitMetaData.AddConnector(pConnector, BACKWARD_DIRECTION));

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CaloHit::RemoveConnection(const CaloHit *const pCaloHit) const
{
	const Connector *pConnector = NULL;
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, m_caloHitMetaData.FindConnector(pCaloHit, pConnector));

	if(!pConnector->IsFrom(pCaloHit) && pConnector->IsTo(pCaloHit))
		return pandora::STATUS_CODE_FAILURE;

	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->Modifiable(this)->m_caloHitMetaData.RemoveConnector(pConnector));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->Modifiable(pCaloHit)->m_caloHitMetaData.RemoveConnector(pConnector));

	delete pConnector;
	pConnector = NULL;

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CaloHit::RemoveAllConnections() const
{
	for(ConnectorList::const_iterator iter = m_caloHitMetaData.GetConnectorList(BACKWARD_DIRECTION).begin(),
			endIter = m_caloHitMetaData.GetConnectorList(BACKWARD_DIRECTION).end() ;
			endIter != iter ; ++iter)
	{
		const Connector *const pConnector = *iter;
		const CaloHit *const pCaloHitFrom = pConnector->GetFrom();

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveConnection(pCaloHitFrom));
	}

	for(ConnectorList::const_iterator iter = m_caloHitMetaData.GetConnectorList(FORWARD_DIRECTION).begin(),
			endIter = m_caloHitMetaData.GetConnectorList(FORWARD_DIRECTION).end() ;
			endIter != iter ; ++iter)
	{
		const Connector *const pConnector = *iter;
		const CaloHit *const pCaloHitTo = pConnector->GetTo();

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->RemoveConnection(pCaloHitTo));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode CaloHit::SetTag(HitTag tag, bool value) const
{
	HitTagMap::const_iterator findIter = m_hitTagMap.find(tag);

	if(findIter == m_hitTagMap.end())
		return pandora::STATUS_CODE_NOT_FOUND;

	this->Modifiable(this)->m_hitTagMap[tag] = value;

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool CaloHit::GetTag(HitTag tag) const
{
	HitTagMap::const_iterator findIter = m_hitTagMap.find(tag);

	if(findIter == m_hitTagMap.end())
		return false;

	return findIter->second;
}

//------------------------------------------------------------------------------------------------------------------------------------------

void CaloHit::ClearTagMap() const
{
	this->Modifiable(this)->m_hitTagMap[CORE_HIT] = false;
	this->Modifiable(this)->m_hitTagMap[ISOLATED_HIT] = false;
	this->Modifiable(this)->m_hitTagMap[MIP_HIT] = false;
	this->Modifiable(this)->m_hitTagMap[NOISE_HIT] = false;
}

//------------------------------------------------------------------------------------------------------------------------------------------

CaloHit *CaloHit::Modifiable(const CaloHit *const pCaloHit) const
{
	return const_cast<CaloHit*>(pCaloHit);
}

//------------------------------------------------------------------------------------------------------------------------------------------

Connector *CaloHit::Modifiable(const Connector *const pConnector) const
{
	return const_cast<Connector*>(pConnector);
}

} 


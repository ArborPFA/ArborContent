  /// \file GapCrossingConnectionTool.cc
/*
 *
 * GapCrossingConnectionTool.cc source template automatically generated by a class generator
 * Creation date : mer. d�c. 9 2015
 *
 * This file is part of ArborContent libraries.
 * 
 * ArborContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * ArborContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ArborContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "ArborTools/GapCrossingConnectionTool.h"

#include "Pandora/AlgorithmHeaders.h"
#include "Helpers/ClusterFitHelper.h"
#include "ArborApi/ArborContentApi.h"

#include "ArborHelpers/CaloHitHelper.h"
#include "ArborObjects/CaloHit.h"
#include "ArborObjects/Connector.h"

namespace arbor_content
{

pandora::StatusCode GapCrossingConnectionTool::Process(const pandora::Algorithm &/*algorithm*/, const pandora::CaloHitList *const pCaloHitList)
{
	pandora::CaloHitList leafCaloHitList;
	pandora::CaloHitList seedCaloHitList;

	// Find all leaves and seeds. Discriminate hits that are seeds and leaves at the same time
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::ExtractLeafCaloHitList(pCaloHitList, leafCaloHitList, false));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::ExtractSeedCaloHitList(pCaloHitList, seedCaloHitList, false));

//	std::cout << "leafCaloHitList.size() : " << leafCaloHitList.size() << std::endl;
//	std::cout << "seedCaloHitList.size() : " << seedCaloHitList.size() << std::endl;

	GapCrossingInfoMap forwardGapCrossingInfoMap;
	GapCrossingInfoMap backwardGapCrossingInfoMap;

	// Find connectable hits that are about to cross a gap or has just crossed a gap
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindForwardConnectableHits(leafCaloHitList, forwardGapCrossingInfoMap));
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->FindBackwardConnectableHits(seedCaloHitList, backwardGapCrossingInfoMap));

//	std::cout << "forwardGapCrossingInfoMap.size() : " << forwardGapCrossingInfoMap.size() << std::endl;
//	std::cout << "backwardGapCrossingInfoMap.size() : " << backwardGapCrossingInfoMap.size() << std::endl;

	// Connect the two lists together
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, this->ConnectCrossGapHits(forwardGapCrossingInfoMap, backwardGapCrossingInfoMap));

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------
// leaving clusters !
pandora::StatusCode GapCrossingConnectionTool::FindForwardConnectableHits(const pandora::CaloHitList &leafCaloHitList, GapCrossingInfoMap &forwardGapCrossingInfoMap) const
{
	const float ecalBarrelOuterRCoordinate = this->GetPandora().GetGeometry()->GetSubDetector(pandora::ECAL_BARREL).GetOuterRCoordinate();
	const float ecalBarrelOuterZCoordinate = this->GetPandora().GetGeometry()->GetSubDetector(pandora::ECAL_BARREL).GetOuterZCoordinate();
	const float hcalBarrelOuterZCoordinate = this->GetPandora().GetGeometry()->GetSubDetector(pandora::HCAL_BARREL).GetOuterZCoordinate();
	const float hcalEndcapInnerZCoordinate = this->GetPandora().GetGeometry()->GetSubDetector(pandora::HCAL_ENDCAP).GetInnerZCoordinate();
	const float ecalEndcapOuterZCoordinate = this->GetPandora().GetGeometry()->GetSubDetector(pandora::ECAL_ENDCAP).GetOuterZCoordinate();

	float hcalRingOuterZCoordinate(std::numeric_limits<float>::max());

	if(!m_hcalRingDetectorName.empty())
	{
		hcalRingOuterZCoordinate = this->GetPandora().GetGeometry()->GetSubDetector(m_hcalRingDetectorName).GetOuterZCoordinate();
	}

	const unsigned int lastECalBarrelPseudoLayer = this->GetPandora().GetPlugins()->GetPseudoLayerPlugin()->GetPseudoLayer(pandora::CartesianVector(0.f, ecalBarrelOuterRCoordinate, 0.f));

	for(pandora::CaloHitList::const_iterator iter = leafCaloHitList.begin() , endIter = leafCaloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const arbor_content::CaloHit *const pCaloHit = dynamic_cast<const arbor_content::CaloHit *const>(*iter);

		if(NULL == pCaloHit)
			continue;

		const pandora::HitRegion hitRegion(pCaloHit->GetHitRegion());
		const pandora::HitType hitType(pCaloHit->GetHitType());

		// TODO handle leaving region 5

		if(hitRegion == pandora::BARREL && hitType == pandora::ECAL)
		{
			if(lastECalBarrelPseudoLayer - pCaloHit->GetPseudoLayer() > m_maxPseudoLayerToEdge
			&& ecalBarrelOuterZCoordinate - fabs(pCaloHit->GetPositionVector().GetZ()) > m_maxDistanceToDetectorZEdge)
				continue;
		}
		else if(hitRegion == pandora::ENDCAP && hitType == pandora::ECAL)
		{
			if(ecalEndcapOuterZCoordinate - fabs(pCaloHit->GetPositionVector().GetZ()) > m_maxDistanceToDetectorZEdge
			&& !pCaloHit->IsInOuterSamplingLayer())
				continue;
		}
		else if(hitRegion == pandora::BARREL && hitType == pandora::HCAL)
		{
			if(hcalBarrelOuterZCoordinate - fabs(pCaloHit->GetPositionVector().GetZ()) > m_maxDistanceToDetectorZEdge)
				continue;
		}
		else if(hitRegion == pandora::ENDCAP && hitType == pandora::HCAL)
		{
			// HCal ring case !
			if(fabs(pCaloHit->GetPositionVector().GetZ()) > ecalBarrelOuterZCoordinate
			&& fabs(pCaloHit->GetPositionVector().GetZ()) < hcalEndcapInnerZCoordinate
			&& !m_hcalRingDetectorName.empty()) // hcal ring detector geo key specified
			{
				// Am i leaving the hcal ring ?
				if(hcalRingOuterZCoordinate - fabs(pCaloHit->GetPositionVector().GetZ()) >  m_maxDistanceToDetectorZEdge)
					continue;
			}
		}
		// unknown hit or out of purpose of this function
		else
			continue;

		pandora::ClusterFitResult fitResult;
		pandora::ClusterFitPointList clusterFitPointList;
		pandora::CaloHitList fitCaloHits;
		fitCaloHits.insert(pCaloHit);

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::BuildCaloHitList(pCaloHit, BACKWARD_DIRECTION, fitCaloHits, m_minECalBranchFitLength, std::numeric_limits<unsigned int>::max()));

		if(fitCaloHits.size() < m_minECalBranchFitLength)
			continue;

		for(pandora::CaloHitList::iterator fitHitIter = fitCaloHits.begin(), fitHitEndIter = fitCaloHits.end() ;
				fitHitEndIter != fitHitIter ; ++fitHitIter)
			clusterFitPointList.push_back(pandora::ClusterFitPoint(*fitHitIter));

		pandora::StatusCode statusCode = pandora::ClusterFitHelper::FitPoints(clusterFitPointList, fitResult);

		if(statusCode != pandora::STATUS_CODE_SUCCESS || !fitResult.IsFitSuccessful())
			continue;

		forwardGapCrossingInfoMap[pCaloHit].m_pCaloHit = pCaloHit;
		forwardGapCrossingInfoMap[pCaloHit].m_fitResult = fitResult;
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

// entering clusters !!
pandora::StatusCode GapCrossingConnectionTool::FindBackwardConnectableHits(const pandora::CaloHitList &seedCaloHitList, GapCrossingInfoMap &backwardGapCrossingInfoMap) const
{
	for(pandora::CaloHitList::const_iterator iter = seedCaloHitList.begin() , endIter = seedCaloHitList.end() ;
			endIter != iter ; ++iter)
	{
		const arbor_content::CaloHit *const pCaloHit = dynamic_cast<const arbor_content::CaloHit *const>(*iter);

		if(NULL == pCaloHit)
			continue;

		const pandora::HitRegion hitRegion(pCaloHit->GetHitRegion());
		const pandora::HitType hitType(pCaloHit->GetHitType());

		// TODO handle entering region 4 and 5

		// hcal barrel, ring and endcap handling
		if((hitRegion == pandora::ENDCAP || hitRegion == pandora::BARREL ) && hitType == pandora::HCAL)
		{
			if(pCaloHit->GetLayer() > m_maxPseudoLayerToEdge)
				continue;
		}
		else if(hitRegion == pandora::ENDCAP && hitType == pandora::ECAL)
		{
			if(pCaloHit->GetLayer() > m_maxPseudoLayerToEdge)
//			|| pCaloHit->GetPositionVector().GetZ())
				continue;
		}
		// unknown hit or out of the scope of this function
		else
			continue;

		pandora::CaloHitList treeFitCaloHitList;
		treeFitCaloHitList.insert(pCaloHit);
		pandora::ClusterFitPointList fitPointList;
		pandora::ClusterFitResult fitResult;

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, CaloHitHelper::BuildCaloHitList(pCaloHit, FORWARD_DIRECTION, treeFitCaloHitList, m_maxHCalClusterFitLayers, std::numeric_limits<float>::max()));

		if(treeFitCaloHitList.size() < m_minHCalClusterSize)
			continue;

		for(pandora::CaloHitList::const_iterator fitHitIter = treeFitCaloHitList.begin(), fitHitEndIter = treeFitCaloHitList.end() ;
				fitHitEndIter != fitHitIter ; ++fitHitIter)
			fitPointList.push_back(pandora::ClusterFitPoint(*fitHitIter));

		const pandora::StatusCode statusCode = pandora::ClusterFitHelper::FitPoints(fitPointList, fitResult);

		if(statusCode != pandora::STATUS_CODE_SUCCESS || !fitResult.IsFitSuccessful())
			continue;

		backwardGapCrossingInfoMap[pCaloHit].m_pCaloHit = pCaloHit;
		backwardGapCrossingInfoMap[pCaloHit].m_fitResult = fitResult;
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode GapCrossingConnectionTool::ConnectCrossGapHits(const GapCrossingInfoMap &forwardGapCrossingInfoMap, const GapCrossingInfoMap &backwardGapCrossingInfoMap) const
{
	for(GapCrossingInfoMap::const_iterator hcalIter = backwardGapCrossingInfoMap.begin(), hcalEndIter = backwardGapCrossingInfoMap.end() ;
			hcalEndIter != hcalIter ; ++hcalIter)
	{
		const arbor_content::CaloHit *pHCalSeedCaloHit = hcalIter->second.m_pCaloHit;

		GapCrossingInfoMap::const_iterator bestCompatibleConnection = forwardGapCrossingInfoMap.end();
		float bestChi2 = std::numeric_limits<float>::max();

		for(GapCrossingInfoMap::const_iterator ecalIter = forwardGapCrossingInfoMap.begin(), ecalEndIter = forwardGapCrossingInfoMap.end() ;
				ecalEndIter != ecalIter ; ++ecalIter)
		{
			if(hcalIter->first->GetHitRegion() != ecalIter->first->GetHitRegion())
				continue;

			const pandora::CartesianVector ecalFitDirection(ecalIter->second.m_fitResult.GetDirection());

			const float fitAngleDifference = ecalFitDirection.GetOpeningAngle(hcalIter->first->GetPositionVector() - ecalIter->first->GetPositionVector());
			const float fitAngleDifference2 = ecalFitDirection.GetOpeningAngle(hcalIter->second.m_fitResult.GetDirection());
			const float normalizedFitAngle = fitAngleDifference/m_crossGapFitAngleDifferenceCut;
			const float normalizedFitAngle2 = fitAngleDifference2/m_crossGapFitAngleDifferenceCut2;

			if(normalizedFitAngle >= 1.f)// || normalizedFitAngle2 >= 1.f)
				continue;

			const float chi2 = normalizedFitAngle*normalizedFitAngle + normalizedFitAngle2*normalizedFitAngle2;

			if(bestChi2 > chi2)
			{
				bestChi2 = chi2;
				bestCompatibleConnection = ecalIter;
			}
		}

		if(bestCompatibleConnection == forwardGapCrossingInfoMap.end())
			continue;

		const arbor_content::CaloHit *pECalLeafCaloHit = bestCompatibleConnection->second.m_pCaloHit;
		const float connectorNormalization = (pECalLeafCaloHit->GetPositionVector() - pHCalSeedCaloHit->GetPositionVector()).GetMagnitude();

		PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, ArborContentApi::Connect(pECalLeafCaloHit, pHCalSeedCaloHit, FORWARD_DIRECTION, connectorNormalization));
	}

	return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode GapCrossingConnectionTool::ReadSettings(const pandora::TiXmlHandle xmlHandle)
{
	m_maxDistanceToDetectorXYEdge = 25.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxDistanceToDetectorXYEdge", m_maxDistanceToDetectorXYEdge));

	m_maxDistanceToDetectorZEdge = 25.f;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxDistanceToDetectorZEdge", m_maxDistanceToDetectorZEdge));

	m_maxPseudoLayerToEdge = 2;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxPseudoLayerToEdge", m_maxPseudoLayerToEdge));

	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"HCalRingDetectorName", m_hcalRingDetectorName));

	m_minHCalClusterSize = 3;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MinHCalClusterSize", m_minHCalClusterSize));

	m_minECalBranchFitLength = 4;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MinECalBranchFitLength", m_minECalBranchFitLength));

	m_maxHCalClusterFitLayers = 4;
	PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
			"MaxHCalClusterFitLayers", m_maxHCalClusterFitLayers));

    m_crossGapFitAngleDifferenceCut = 0.8;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        	"CrossGapFitAngleDifferenceCut", m_crossGapFitAngleDifferenceCut));

    m_crossGapFitAngleDifferenceCut2 = 0.8;
    PANDORA_RETURN_RESULT_IF_AND_IF(pandora::STATUS_CODE_SUCCESS, pandora::STATUS_CODE_NOT_FOUND, !=, pandora::XmlHelper::ReadValue(xmlHandle,
        	"CrossGapFitAngleDifferenceCut2", m_crossGapFitAngleDifferenceCut2));

	return pandora::STATUS_CODE_SUCCESS;
}

} 

